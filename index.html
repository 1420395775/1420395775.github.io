<!DOCTYPE html>
<html lang="zh-CN">
<head>

    <!--[if lt IE 9]>
        <style>body {display: none; background: none !important} </style>
        <meta http-equiv="Refresh" Content="0; url=//outdatedbrowser.com/" />
    <![endif]-->

<meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge, chrome=1" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no">
<meta name="format-detection" content="telephone=no" />
<meta name="author" content="ying" />


    
    


<meta property="og:type" content="website">
<meta property="og:title" content="Yeing.lx">
<meta property="og:url" content="http://yoursite.com/index.html">
<meta property="og:site_name" content="Yeing.lx">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Yeing.lx">

<link rel="apple-touch-icon" href= "/apple-touch-icon.png">


    <link rel="alternate" href="/atom.xml" title="Yeing.lx" type="application/atom+xml">



    <link rel="shortcut icon" href="/favicon.png">



    <link href="//cdn.bootcss.com/animate.css/3.5.1/animate.min.css" rel="stylesheet">



    <link href="//cdn.bootcss.com/fancybox/2.1.5/jquery.fancybox.min.css" rel="stylesheet">



    <script src="//cdn.bootcss.com/pace/1.0.2/pace.min.js"></script>
    <link href="//cdn.bootcss.com/pace/1.0.2/themes/blue/pace-theme-minimal.css" rel="stylesheet">


<link rel="stylesheet" href="/css/style.css">


    <style> .article { opacity: 0;} </style>


<link href="//cdn.bootcss.com/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet">


<title>Yeing.lx</title>

<script src="//cdn.bootcss.com/jquery/2.2.4/jquery.min.js"></script>
<script src="//cdn.bootcss.com/clipboard.js/1.5.10/clipboard.min.js"></script>

<script>
    var yiliaConfig = {
        fancybox: true,
        animate: true,
        isHome: true,
        isPost: false,
        isArchive: false,
        isTag: false,
        isCategory: false,
        fancybox_js: "//cdn.bootcss.com/fancybox/2.1.5/jquery.fancybox.min.js",
        scrollreveal: "//cdn.bootcss.com/scrollReveal.js/3.1.4/scrollreveal.min.js",
        search: undefined
    }
</script>


    <script> yiliaConfig.jquery_ui = [false]; </script>



    <script> yiliaConfig.rootUrl = "\/";</script>






</head>
<body>
  <div id="container">
    <div class="left-col">
    <div class="overlay"></div>
<div class="intrude-less">
    <header id="header" class="inner">
        <a href="/" class="profilepic">
            <img src="/img/xx.jpg" class="animated zoomIn">
        </a>
        <hgroup>
          <h1 class="header-author"><a href="/">ying</a></h1>
        </hgroup>

        

        


        
            <div id="switch-btn" class="switch-btn">
                <div class="icon">
                    <div class="icon-ctn">
                        <div class="icon-wrap icon-house" data-idx="0">
                            <div class="birdhouse"></div>
                            <div class="birdhouse_holes"></div>
                        </div>
                        <div class="icon-wrap icon-ribbon hide" data-idx="1">
                            <div class="ribbon"></div>
                        </div>
                        
                        <div class="icon-wrap icon-link hide" data-idx="2">
                            <div class="loopback_l"></div>
                            <div class="loopback_r"></div>
                        </div>
                        
                        
                        <div class="icon-wrap icon-me hide" data-idx="3">
                            <div class="user"></div>
                            <div class="shoulder"></div>
                        </div>
                        
                    </div>
                    
                </div>
                <div class="tips-box hide">
                    <div class="tips-arrow"></div>
                    <ul class="tips-inner">
                        <li>菜单</li>
                        <li>标签</li>
                        
                        <li>友情链接</li>
                        
                        
                        <li>关于我</li>
                        
                    </ul>
                </div>
            </div>
        

        <div id="switch-area" class="switch-area">
            <div class="switch-wrap">
                <section class="switch-part switch-part1">
                    <nav class="header-menu">
                        <ul>
                        
                            <li><a href="/">主页</a></li>
                        
                            <li><a href="/archives/">所有文章</a></li>
                        
                            <li><a href="/tags/">标签云</a></li>
                        
                            <li><a href="/about/">关于我</a></li>
                        
                        </ul>
                    </nav>
                    <nav class="header-nav">
                        <ul class="social">
                            
                                <a class="fa Email" href="/1420395775@qq.com" title="Email"></a>
                            
                                <a class="fa GitHub" href="https://github.com/1420395775/1420395775.github.io.git" title="GitHub"></a>
                            
                                <a class="fa RSS" href="/atom.xml" title="RSS"></a>
                            
                                <a class="fa 网易云音乐" href="https://www.baidu.com/link?url=YcMxC9Fp1zz5kRlP-Em8frgUZH1k4M4KkXBpdqslL2y&wd=&eqid=e5d5b6e4000d8f2a00000006592075ea" title="网易云音乐"></a>
                            
                        </ul>
                    </nav>
                </section>
                
                
                <section class="switch-part switch-part2">
                    <div class="widget tagcloud" id="js-tagcloud">
                        
                    </div>
                </section>
                
                
                
                <section class="switch-part switch-part3">
                    <div id="js-friends">
                    
                      <a class="main-nav-link switch-friends-link" href="https://hexo.io">Hexo</a>
                    
                      <a class="main-nav-link switch-friends-link" href="https://pages.github.com/">GitHub</a>
                    
                      <a class="main-nav-link switch-friends-link" href="http://moxfive.xyz/">MOxFIVE</a>
                    
                    </div>
                </section>
                

                
                
                <section class="switch-part switch-part4">
                
                    <div id="js-aboutme">专注于前端</div>
                </section>
                
            </div>
        </div>
    </header>                
</div>
    </div>
    <div class="mid-col">
      <nav id="mobile-nav">
      <div class="overlay">
          <div class="slider-trigger"></div>
          <h1 class="header-author js-mobile-header hide"><a href="/" title="回到主页">ying</a></h1>
      </div>
    <div class="intrude-less">
        <header id="header" class="inner">
            <a href="/" class="profilepic">
                <img src="/img/xx.jpg" class="animated zoomIn">
            </a>
            <hgroup>
              <h1 class="header-author"><a href="/" title="回到主页">ying</a></h1>
            </hgroup>
            
            <nav class="header-menu">
                <ul>
                
                    <li><a href="/">主页</a></li>
                
                    <li><a href="/archives/">所有文章</a></li>
                
                    <li><a href="/tags/">标签云</a></li>
                
                    <li><a href="/about/">关于我</a></li>
                
                <div class="clearfix"></div>
                </ul>
            </nav>
            <nav class="header-nav">
                        <ul class="social">
                            
                                <a class="fa Email" target="_blank" href="/1420395775@qq.com" title="Email"></a>
                            
                                <a class="fa GitHub" target="_blank" href="https://github.com/1420395775/1420395775.github.io.git" title="GitHub"></a>
                            
                                <a class="fa RSS" target="_blank" href="/atom.xml" title="RSS"></a>
                            
                                <a class="fa 网易云音乐" target="_blank" href="https://www.baidu.com/link?url=YcMxC9Fp1zz5kRlP-Em8frgUZH1k4M4KkXBpdqslL2y&wd=&eqid=e5d5b6e4000d8f2a00000006592075ea" title="网易云音乐"></a>
                            
                        </ul>
            </nav>
        </header>                
    </div>
    <link class="menu-list" tags="标签" friends="友情链接" about="关于我"/>
</nav>
      <div class="body-wrap">
  
    <article id="post-js性能优化" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2017/06/03/js性能优化/" class="article-date">
      <time datetime="2017-06-03T09:07:03.055Z" itemprop="datePublished">2017-06-03</time>
</a>


    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
    <div class="article-entry" itemprop="articleBody">
      
          
        <h3 id="JavaScript性能优化小知识总结"><a href="#JavaScript性能优化小知识总结" class="headerlink" title="JavaScript性能优化小知识总结"></a>JavaScript性能优化小知识总结</h3><p>前言<br>一直在学习javascript，也有看过《犀利开发Jquery内核详解与实践》，对这本书的评价只有两个字犀利，可能是对javascript理解的还不够透彻异或是自己太笨，更多的是自己不擅于思考懒得思考以至于里面说的一些精髓都没有太深入的理解。</p>
<p>鉴于想让自己有一个提升，进不了一个更加广阔的天地，总得找一个属于自己的居所好好生存，所以平时会有意无意的去积累一些使用jQuerry的常用知识，特别是对于性能要求这一块，总是会想是不是有更好的方式来实现。</p>
<p>下面是我总结的一些小技巧，仅供参考。(我先会说一个总标题，然后用一小段话来说明这个意思 再最后用一个demo来简单言明)</p>
<p>避免全局查找<br>在一个函数中会用到全局对象存储为局部变量来减少全局查找，因为访问局部变量的速度要比访问全局变量的速度更快些。</p>
<pre><code>function search() {
        //当我要使用当前页面地址和主机域名
        alert(window.location.href + window.location.host);
    }
    //最好的方式是如下这样  先用一个简单变量保存起来
    function search() {
        var location = window.location;
        alert(location.href + location.host);
    }
</code></pre><p>定时器<br>如果针对的是不断运行的代码，不应该使用setTimeout，而应该是用setInterval，因为setTimeout每一次都会初始化一个定时器，而setInterval只会在开始的时候初始化一个定时器</p>
<pre><code>var timeoutTimes = 0;
function timeout() {
    timeoutTimes++;
    if (timeoutTimes &lt; 10) {
        setTimeout(timeout, 10);
    }
}
timeout();
//可以替换为：
var intervalTimes = 0;
function interval() {
    intervalTimes++;
    if (intervalTimes &gt;= 10) {
        clearInterval(interv);
    }
}
var interv = setInterval(interval, 10);
</code></pre><p>字符串连接<br>如果要连接多个字符串，应该少使用+=，如</p>
<p>s+=a;</p>
<p>s+=b;</p>
<p>s+=c;<br>应该写成s+=a + b + c；</p>
<p>而如果是收集字符串，比如多次对同一个字符串进行+=操作的话，最好使用一个缓存，使用JavaScript数组来收集，最后使用join方法连接起来。</p>
<pre><code>var buf = [];
for (var i = 0; i &lt; 100; i++) {
    buf.push(i.toString());
}
var all = buf.join(&quot;&quot;);
</code></pre><p>避免with语句<br>和函数类似 ，with语句会创建自己的作用域，因此会增加其中执行的代码的作用域链的长度，由于额外的作用域链的查找，在with语句中执行的代码肯定会比外面执行的代码要慢，在能不使用with语句的时候尽量不要使用with语句。</p>
<p> with (a.b.c.d) {<br>            property1 = 1;<br>            property2 = 2;<br>        }<br>        //可以替换为：<br>        var obj = a.b.c.d;<br>        obj.property1 = 1;<br>        obj.property2 = 2;<br>数字转换成字符串<br>般最好用”” + 1来将数字转换成字符串，虽然看起来比较丑一点，但事实上这个效率是最高的，性能上来说：</p>
<p>(“” +) &gt; String() &gt; .toString() &gt; new String()<br>浮点数转换成整型<br>很多人喜欢使用parseInt()，其实parseInt()是用于将字符串转换成数字，而不是浮点数和整型之间的转换，我们应该使用Math.floor()或者Math.round()</p>
<p>各种类型转换<br>var myVar = “3.14159”,<br>        str = “” + myVar, //  to string<br>        i_int = ~ ~myVar,  //  to integer<br>        f_float = 1 <em> myVar,  //  to float<br>        b_bool = !!myVar,  /</em>  to boolean - any string with length<br>                                and any number except 0 are true */<br>        array = [myVar];  //  to array<br>如果定义了toString()方法来进行类型转换的话，推荐显式调用toString()，因为内部的操作在尝试所有可能性之后，会尝试对象的toString()方法尝试能否转化为String，所以直接调用这个方法效率会更高</p>
<p>多个类型声明<br>在JavaScript中所有变量都可以使用单个var语句来声明，这样就是组合在一起的语句，以减少整个脚本的执行时间，就如上面代码一样，上面代码格式也挺规范，让人一看就明了。</p>
<p>插入迭代器<br>如var name=values[i]; i++;前面两条语句可以写成var name=values[i++]</p>
<p>使用直接量<br>var aTest = new Array(); //替换为<br>        var aTest = [];<br>        var aTest = new Object; //替换为<br>        var aTest = {};<br>        var reg = new RegExp(); //替换为<br>        var reg = /../;<br>        //如果要创建具有一些特性的一般对象，也可以使用字面量，如下：<br>        var oFruit = new O;<br>        oFruit.color = “red”;<br>        oFruit.name = “apple”;<br>        //前面的代码可用对象字面量来改写成这样：<br>        var oFruit = { color: “red”, name: “apple” };<br>使用DocumentFragment优化多次append<br>一旦需要更新DOM,请考虑使用文档碎片来构建DOM结构，然后再将其添加到现存的文档中。</p>
<p>for (var i = 0; i &lt; 1000; i++) {<br>            var el = document.createElement(‘p’);<br>            el.innerHTML = i;<br>            document.body.appendChild(el);<br>        }<br>        //可以替换为：<br>        var frag = document.createDocumentFragment();<br>        for (var i = 0; i &lt; 1000; i++) {<br>            var el = document.createElement(‘p’);<br>            el.innerHTML = i;<br>            frag.appendChild(el);<br>        }<br>        document.body.appendChild(frag);<br>使用一次innerHTML赋值代替构建dom元素<br>对于大的DOM更改，使用innerHTML要比使用标准的DOM方法创建同样的DOM结构快得多。</p>
<pre><code>var frag = document.createDocumentFragment();
for (var i = 0; i &lt; 1000; i++) {
    var el = document.createElement(&apos;p&apos;);
    el.innerHTML = i;
    frag.appendChild(el);
}
document.body.appendChild(frag);
//可以替换为：
var html = [];
for (var i = 0; i &lt; 1000; i++) {
    html.push(&apos;&lt;p&gt;&apos; + i + &apos;&lt;/p&gt;&apos;);
}
document.body.innerHTML = html.join(&apos;&apos;);
</code></pre><p>通过模板元素clone，替代createElement<br>很多人喜欢在JavaScript中使用document.write来给页面生成内容。事实上这样的效率较低，如果需要直接插入HTML，可以找一个容器元素，比如指定一个div或者span，并设置他们的innerHTML来将自己的HTML代码插入到页面中。通常我们可能会使用字符串直接写HTML来创建节点，其实这样做，1无法保证代码的有效性2字符串操作效率低，所以应该是用document.createElement()方法，而如果文档中存在现成的样板节点，应该是用cloneNode()方法，因为使用createElement()方法之后，你需要设置多次元素的属性，使用cloneNode()则可以减少属性的设置次数——同样如果需要创建很多元素，应该先准备一个样板节点。</p>
<pre><code>var frag = document.createDocumentFragment();
for (var i = 0; i &lt; 1000; i++) {
    var el = document.createElement(&apos;p&apos;);
    el.innerHTML = i;
    frag.appendChild(el);
}
document.body.appendChild(frag);
//替换为：
var frag = document.createDocumentFragment();
var pEl = document.getElementsByTagName(&apos;p&apos;)[0];
for (var i = 0; i &lt; 1000; i++) {
    var el = pEl.cloneNode(false);
    el.innerHTML = i;
    frag.appendChild(el);
}
document.body.appendChild(frag);
</code></pre><p>使用firstChild和nextSibling代替childNodes遍历dom元素<br>图片描述</p>
<pre><code>var nodes = element.childNodes;
for (var i = 0, l = nodes.length; i &lt; l; i++) {
    var node = nodes[i];
    //……
}
//可以替换为：
var node = element.firstChild;
while (node) {
    //……
    node = node.nextSibling;
</code></pre><p>删除DOM节点<br>删除dom节点之前,一定要删除注册在该节点上的事件,不管是用observe方式还是用attachEvent方式注册的事件,否则将会产生无法回收的内存。另外，在removeChild和innerHTML=’’二者之间,尽量选择后者. 因为在sIEve(内存泄露监测工具)中监测的结果是用removeChild无法有效地释放dom节点</p>
<p>使用事件代理<br>任何可以冒泡的事件都不仅仅可以在事件目标上进行处理，目标的任何祖先节点上也能处理，使用这个知识就可以将事件处理程序附加到更高的地方负责多个目标的事件处理，同样，对于内容动态增加并且子节点都需要相同的事件处理函数的情况，可以把事件注册提到父节点上，这样就不需要为每个子节点注册事件监听了。另外，现有的js库都采用observe方式来创建事件监听,其实现上隔离了dom对象和事件处理函数之间的循环引用,所以应该尽量采用这种方式来创建事件监听</p>
<p>重复使用的调用结果，事先保存到局部变量</p>
<pre><code>//避免多次取值的调用开销
var h1 = element1.clientHeight + num1;
var h2 = element1.clientHeight + num2;
//可以替换为：
var eleHeight = element1.clientHeight;
var h1 = eleHeight + num1;
var h2 = eleHeight + num2;
</code></pre><p>注意NodeList<br>最小化访问NodeList的次数可以极大的改进脚本的性能</p>
<pre><code>var images = document.getElementsByTagName(&apos;img&apos;);
for (var i = 0, len = images.length; i &lt; len; i++) {

}
</code></pre><p>编写JavaScript的时候一定要知道何时返回NodeList对象，这样可以最小化对它们的访问</p>
<p>进行了对getElementsByTagName()的调用<br>获取了元素的childNodes属性<br>获取了元素的attributes属性<br>访问了特殊的集合，如document.forms、document.images等等<br>要了解了当使用NodeList对象时，合理使用会极大的提升代码执行速度</p>
<p>优化循环<br>可以使用下面几种方式来优化循环</p>
<p>减值迭代<br>大多数循环使用一个从0开始、增加到某个特定值的迭代器，在很多情况下，从最大值开始，在循环中不断减值的迭代器更加高效</p>
<p>简化终止条件<br>由于每次循环过程都会计算终止条件，所以必须保证它尽可能快，也就是说避免属性查找或者其它的操作，最好是将循环控制量保存到局部变量中，也就是说对数组或列表对象的遍历时，提前将length保存到局部变量中，避免在循环的每一步重复取值。</p>
<pre><code>var list = document.getElementsByTagName(&apos;p&apos;);
for (var i = 0; i &lt; list.length; i++) {
    //……
}

//替换为：
var list = document.getElementsByTagName(&apos;p&apos;);
for (var i = 0, l = list.length; i &lt; l; i++) {
    //……
}
</code></pre><p>简化循环体<br>循环体是执行最多的，所以要确保其被最大限度的优化</p>
<p>使用后测试循环<br>在JavaScript中，我们可以使用for(;;),while(),for(in)三种循环，事实上，这三种循环中for(in)的效率极差，因为他需要查询散列键，只要可以，就应该尽量少用。for(;;)和while循环，while循环的效率要优于for(;;)，可能是因为for(;;)结构的问题，需要经常跳转回去。</p>
<pre><code>var arr = [1, 2, 3, 4, 5, 6, 7];
var sum = 0;
for (var i = 0, l = arr.length; i &lt; l; i++) {
    sum += arr[i];
}

//可以考虑替换为：

var arr = [1, 2, 3, 4, 5, 6, 7];
var sum = 0, l = arr.length;
while (l--) {
    sum += arr[l];
}
</code></pre><p>最常用的for循环和while循环都是前测试循环，而如do-while这种后测试循环，可以避免最初终止条件的计算，因此运行更快。</p>
<p>展开循环<br>当循环次数是确定的，消除循环并使用多次函数调用往往会更快。</p>
<p>避免双重解释<br>如果要提高代码性能，尽可能避免出现需要按照JavaScript解释的字符串，也就是</p>
<p>尽量少使用eval函数<br>使用eval相当于在运行时再次调用解释引擎对内容进行运行，需要消耗大量时间，而且使用Eval带来的安全性问题也是不容忽视的。</p>
<p>不要使用Function构造器<br>不要给setTimeout或者setInterval传递字符串参数</p>
<pre><code>var num = 0;
setTimeout(&apos;num++&apos;, 10);
//可以替换为：
var num = 0;
function addNum() {
    num++;
}
setTimeout(addNum, 10);
</code></pre><p>缩短否定检测<br>       if (oTest != ‘#ff0000’) {<br>            //do something<br>        }<br>        if (oTest != null) {<br>            //do something<br>        }<br>        if (oTest != false) {<br>            //do something<br>        }<br>        //虽然这些都正确，但用逻辑非操作符来操作也有同样的效果：<br>        if (!oTest) {<br>            //do something<br>        }<br>条件分支<br>将条件分支，按可能性顺序从高到低排列：可以减少解释器对条件的探测次数<br>在同一条件子的多（&gt;2）条件分支时，使用switch优于if：switch分支选择的效率高于if，在IE下尤为明显。4分支的测试，IE下switch的执行时间约为if的一半。<br>使用三目运算符替代条件分支<br>        if (a &gt; b) {<br>            num = a;<br>        } else {<br>            num = b;<br>        }<br>        //可以替换为：<br>        num = a &gt; b ? a : b;<br>使用常量<br>重复值：任何在多处用到的值都应该抽取为一个常量<br>用户界面字符串：任何用于显示给用户的字符串，都应该抽取出来以方便国际化<br>URLs：在Web应用中，资源位置很容易变更，所以推荐用一个公共地方存放所有的URL<br>任意可能会更改的值：每当你用到字面量值的时候，你都要问一下自己这个值在未来是不是会变化，如果答案是“是”，那么这个值就应该被提取出来作为一个常量。<br>避免与null进行比较<br>由于JavaScript是弱类型的，所以它不会做任何的自动类型检查，所以如果看到与null进行比较的代码，尝试使用以下技术替换</p>
<p>如果值应为一个引用类型，使用instanceof操作符检查其构造函数<br>如果值应为一个基本类型，作用typeof检查其类型<br>如果是希望对象包含某个特定的方法名，则使用typeof操作符确保指定名字的方法存在于对象上<br>避免全局量<br>全局变量应该全部字母大写，各单词之间用_下划线来连接。尽可能避免全局变量和函数, 尽量减少全局变量的使用，因为在一个页面中包含的所有JavaScript都在同一个域中运行。所以如果你的代码中声明了全局变量或者全局函数的话，后面的代码中载入的脚本文件中的同名变量和函数会覆盖掉（overwrite）你的。</p>
<p>//糟糕的全局变量和全局函数<br>var current = null;<br>function init(){<br>//…<br>}<br>function change() {<br>    //…<br>}<br>function verify() {<br>    //…<br>}<br>//解决办法有很多，Christian Heilmann建议的方法是：<br>//如果变量和函数不需要在“外面”引用，那么就可以使用一个没有名字的方法将他们全都包起来。<br>(function(){<br>var current = null;<br>function init() {<br>    //…<br>}<br>function change() {<br>    //…<br>}<br>function verify() {<br>    //…<br>}<br>})();<br>//如果变量和函数需要在“外面”引用，需要把你的变量和函数放在一个“命名空间”中<br>//我们这里用一个function做命名空间而不是一个var，因为在前者中声明function更简单，而且能保护隐私数据<br>myNameSpace = function() {<br>    var current = null;</p>
<pre><code>function init() {
    //...
}

function change() {
    //...
}

function verify() {
    //...
}
</code></pre><p>//所有需要在命名空间外调用的函数和属性都要写在return里面<br>    return {<br>        init: init,<br>        //甚至你可以为函数和属性命名一个别名<br>        set: change<br>    };<br>};<br>尊重对象的所有权<br>因为JavaScript可以在任何时候修改任意对象，这样就可以以不可预计的方式覆写默认的行为，所以如果你不负责维护某个对象，它的对象或者它的方法，那么你就不要对它进行修改，具体一点就是说：</p>
<p>不要为实例或原型添加属性<br>不要为实例或者原型添加方法<br>不要重定义已经存在的方法<br>不要重复定义其它团队成员已经实现的方法，永远不要修改不是由你所有的对象，你可以通过以下方式为对象创建新的功能:<br>创建包含所需功能的新对象，并用它与相关对象进行交互<br>创建自定义类型，继承需要进行修改的类型，然后可以为自定义类型添加额外功能<br>循环引用<br>如果循环引用中包含DOM对象或者ActiveX对象，那么就会发生内存泄露。内存泄露的后果是在浏览器关闭前，即使是刷新页面，这部分内存不会被浏览器释放。</p>
<p>简单的循环引用：</p>
<pre><code>var el = document.getElementById(&apos;MyElement&apos;);
var func = function () {
    //…
}
el.func = func;
func.element = el;
</code></pre><p>但是通常不会出现这种情况。通常循环引用发生在为dom元素添加闭包作为expendo的时候。</p>
<pre><code>function init() {
    var el = document.getElementById(&apos;MyElement&apos;);
    el.onclick = function () {
        //……
    }
}
init();
</code></pre><p>init在执行的时候，当前上下文我们叫做context。这个时候，context引用了el，el引用了function，function引用了context。这时候形成了一个循环引用。</p>
<p>下面2种方法可以解决循环引用：</p>
<p>1) 置空dom对象</p>
<pre><code>function init() {
     var el = document.getElementById(&apos;MyElement&apos;);
     el.onclick = function () {
         //……
     }
 }
 init();
 //可以替换为：
 function init() {
     var el = document.getElementById(&apos;MyElement&apos;);
     el.onclick = function () {
         //……
     }
     el = null;
 }
 init();
</code></pre><p>将el置空，context中不包含对dom对象的引用，从而打断循环应用。</p>
<p>如果我们需要将dom对象返回，可以用如下方法：</p>
<pre><code>function init() {
    var el = document.getElementById(&apos;MyElement&apos;);
    el.onclick = function () {
        //……
    }
    return el;
}
init();
//可以替换为：
function init() {
    var el = document.getElementById(&apos;MyElement&apos;);
    el.onclick = function () {
        //……
    }
    try {
        return el;
    } finally {
        el = null;
    }
}
init();
</code></pre><p>2) 构造新的context</p>
<pre><code>function init() {
    var el = document.getElementById(&apos;MyElement&apos;);
    el.onclick = function () {
        //……
    }
}
init();
//可以替换为：
function elClickHandler() {
    //……
}
function init() {
    var el = document.getElementById(&apos;MyElement&apos;);
    el.onclick = elClickHandler;
}
init();
</code></pre><p>把function抽到新的context中，这样，function的context就不包含对el的引用，从而打断循环引用。</p>
<p>通过javascript创建的dom对象，必须append到页面中<br>IE下，脚本创建的dom对象，如果没有append到页面中，刷新页面，这部分内存是不会回收的！</p>
<pre><code>function create() {
    var gc = document.getElementById(&apos;GC&apos;);
    for (var i = 0; i &lt; 5000; i++) {
        var el = document.createElement(&apos;div&apos;);
        el.innerHTML = &quot;test&quot;;
        //下面这句可以注释掉，看看浏览器在任务管理器中，点击按钮然后刷新后的内存变化
        gc.appendChild(el);
    }
}
</code></pre><p>释放dom元素占用的内存<br>将dom元素的innerHTML设置为空字符串，可以释放其子元素占用的内存。</p>
<p>在rich应用中，用户也许会在一个页面上停留很长时间，可以使用该方法释放积累得越来越多的dom元素使用的内存。</p>
<p>释放javascript对象<br>在rich应用中，随着实例化对象数量的增加，内存消耗会越来越大。所以应当及时释放对对象的引用，让GC能够回收这些内存控件。</p>
<p>对象：obj = null<br>对象属性：delete obj.myproperty<br>数组item：使用数组的splice方法释放数组中不用的item<br>避免string的隐式装箱<br>对string的方法调用，比如’xxx’.length，浏览器会进行一个隐式的装箱操作，将字符串先转换成一个String对象。推荐对声明有可能使用String实例方法的字符串时，采用如下写法：</p>
<p>var myString = new String(‘Hello World’);<br>松散耦合<br>1、解耦HTML/JavaScript</p>
<p>JavaScript和HTML的紧密耦合：直接写在HTML中的JavaScript、使用包含内联代码的<script>元素、使用HTML属性来分配事件处理程序等</p>
<p>HTML和JavaScript的紧密耦合：JavaScript中包含HTML，然后使用innerHTML来插入一段html文本到页面</p>
<p>其实应该是保持层次的分离，这样可以很容易的确定错误的来源，所以我们应确保HTML呈现应该尽可能与JavaScript保持分离</p>
<p>2、解耦CSS/JavaScript</p>
<p>显示问题的唯一来源应该是CSS，行为问题的唯一来源应该是JavaScript，层次之间保持松散耦合才可以让你的应用程序更加易于维护，所以像以下的代码element.style.color=”red”尽量改为element.className=”edit”，而且不要在css中通过表达式嵌入JavaScript</p>
<p>3、解耦应用程序/事件处理程序</p>
<p>将应用逻辑和事件处理程序相分离：一个事件处理程序应该从事件对象中提取，并将这些信息传送给处理应用逻辑的某个方法中。这样做的好处首先可以让你更容易更改触发特定过程的事件，其次可以在不附加事件的情况下测试代码，使其更易创建单元测试</p>
<p>性能方面的注意事项<br>1、尽量使用原生方法</p>
<p>2、switch语句相对if较快</p>
<p>通过将case语句按照最可能到最不可能的顺序进行组织</p>
<p>3、位运算较快</p>
<p>当进行数字运算时，位运算操作要比任何布尔运算或者算数运算快</p>
<p>4、巧用||和&amp;&amp;布尔运算符</p>
<pre><code>function eventHandler(e) {
    if (!e) e = window.event;
}
//可以替换为：
function eventHandler(e) {
    e = e || window.event;
}
if (myobj) {
    doSomething(myobj);
}
//可以替换为：
myobj &amp;&amp; doSomething(myobj);
</code></pre><p>避免错误应注意的地方<br>1、每条语句末尾须加分号</p>
<p>在if语句中，即使条件表达式只有一条语句也要用{}把它括起来，以免后续如果添加了语句之后造成逻辑错误</p>
<p>2、使用+号时需谨慎</p>
<p>JavaScript 和其他编程语言不同的是，在 JavaScript 中，’+’除了表示数字值相加，字符串相连接以外，还可以作一元运算符用，把字符串转换为数字。因而如果使用不当，则可能与自增符’++’混淆而引起计算错误</p>
<pre><code>var valueA = 20;
var valueB = &quot;10&quot;;
alert(valueA + valueB);     //ouput: 2010 
alert(valueA + (+valueB));  //output: 30 
alert(valueA + +valueB);    //output:30 
alert(valueA ++ valueB);     //Compile error
</code></pre><p>3、使用return语句需要注意</p>
<p>一条有返回值的return语句不要用()括号来括住返回值，如果返回表达式，则表达式应与return关键字在同一行，以避免压缩时，压缩工具自动加分号而造成返回与开发人员不一致的结果</p>
<pre><code>function F1() {
    var valueA = 1;
    var valueB = 2;
    return valueA + valueB;
}
function F2() {
    var valueA = 1;
    var valueB = 2;
    return
    valueA + valueB;
}
alert(F1());  //output: 3 
alert(F2());  //ouput: undefined
</code></pre><p>==和===的区别<br>避免在if和while语句的条件部分进行赋值，如if (a = b)，应该写成if (a == b)，但是在比较是否相等的情况下，最好使用全等运行符，也就是使用===和!==操作符会相对于==和!=会好点。==和!=操作符会进行类型强制转换</p>
<pre><code>var valueA = &quot;1&quot;;
var valueB = 1;
if (valueA == valueB) {
    alert(&quot;Equal&quot;);
}
else {
    alert(&quot;Not equal&quot;);
}
//output: &quot;Equal&quot;
if (valueA === valueB) {
    alert(&quot;Equal&quot;);
}
else {
    alert(&quot;Not equal&quot;);
}
//output: &quot;Not equal&quot;
</code></pre><p>不要使用生偏语法<br>不要使用生偏语法，写让人迷惑的代码，虽然计算机能够正确识别并运行，但是晦涩难懂的代码不方便以后维护</p>
<p>函数返回统一类型<br>虽然JavaScript是弱类型的，对于函数来说，前面返回整数型数据，后面返回布尔值在编译和运行都可以正常通过，但为了规范和以后维护时容易理解，应保证函数应返回统一的数据类型</p>
<p>总是检查数据类型<br>要检查你的方法输入的所有数据，一方面是为了安全性，另一方面也是为了可用性。用户随时随地都会输入错误的数据。这不是因为他们蠢，而是因为他们很忙，并且思考的方式跟你不同。用typeof方法来检测你的function接受的输入是否合法</p>
<p>何时用单引号，何时用双引号<br>虽然在JavaScript当中，双引号和单引号都可以表示字符串, 为了避免混乱，我们建议在HTML中使用双引号，在JavaScript中使用单引号，但为了兼容各个浏览器，也为了解析时不会出错，定义JSON对象时，最好使用双引号</p>
<p>部署<br>用JSLint运行JavaScript验证器来确保没有语法错误或者是代码没有潜在的问<br>部署之前推荐使用压缩工具将JS文件压缩<br>文件编码统一用UTF-8<br>JavaScript 程序应该尽量放在 .js 的文件中，需要调用的时候在 HTML 中以 <script src=”filename.js”> 的形式包含进来。JavaScript 代码若不是该 HTML 文件所专用的，则应尽量避免在 HTML文件中直接编写 JavaScript 代码。因为这样会大大增加 HTML 文件的大小，无益于代码的压缩和缓存的使用。另外，<script src=”filename.js”> 标签应尽量放在文件的后面,最好是放在</body>标签前。这样会降低因加载 JavaScript 代码而影响页面中其它组件的加载时间。<br>永远不要忽略代码优化工作，重构是一项从项目开始到结束需要持续的工作，只有不断的优化代码才能让代码的执行效率越来越好。</p>
<p>文章源自：<a href="http://www.cnblogs.com/elegance/p/4288435.html">http://www.cnblogs.com/elegance/p/4288435.html</a><br>相关标签：JavaScript</p>
<p> 甄橚 洪水水<em> yahoo16 学来卵用 易黑强蜀黍 congnie1163634218 weibo</em>運掵芝輪 串串好吃3961793 qq_石头<em>444035649 qq</em>菲妤諾_L_04153810<br>36 人推荐<br>相关阅读<br>编写高质量JavaScript代码<br>15个Javascript优化小技巧总结<br>JavaScript 性能优化杀手<br>45个实用的JavaScript技巧、窍门和最佳实践（转载）<br>JavaScript奇技淫巧44招</p>
<p>请登录后，发表评论<br>评论（Enter+Ctrl）<br>1条评论<br>爱代码<em>爱前端1F<br>非常感谢分享。顺便说下，楼下不是啥好东西^</em>^。<br>0回复 2016-01-26 09:52:36</p>
<p>IT程序狮 回复 爱代码_爱前端：<br>嘿嘿。正解。<br>回复 2016-01-26 10:28:55<br>网站首页企业合作人才招聘联系我们讲师招募常见问题意见反馈慕课大学友情链接<br>Copyright © 2017 imooc.com All Rights Reserved | 京ICP备 13046642号-2<br>运行代码运行代码运行代码运行代码运行代码运行代码运行代码运行代码运行代码运行代码运行代码运行代码运行代码运行代码运行代码运行代码运行代码运行代码运行代码运行代码运行代码运行代码运行代码运行代码运行代码运行代码运行代码运行代码运行代码运行代码运行代码<br>前言<br>一直在学习javascript，也有看过《犀利开发Jquery内核详解与实践》，对这本书的评价只有两个字犀利，可能是对javascript理解的还不够透彻异或是自己太笨，更多的是自己不擅于思考懒得思考以至于里面说的一些精髓都没有太深入的理解。</p>
<p>鉴于想让自己有一个提升，进不了一个更加广阔的天地，总得找一个属于自己的居所好好生存，所以平时会有意无意的去积累一些使用jQuerry的常用知识，特别是对于性能要求这一块，总是会想是不是有更好的方式来实现。</p>
<p>下面是我总结的一些小技巧，仅供参考。(我先会说一个总标题，然后用一小段话来说明这个意思 再最后用一个demo来简单言明)</p>
<p>避免全局查找<br>在一个函数中会用到全局对象存储为局部变量来减少全局查找，因为访问局部变量的速度要比访问全局变量的速度更快些。</p>
<pre><code>function search() {
        //当我要使用当前页面地址和主机域名
        alert(window.location.href + window.location.host);
    }
    //最好的方式是如下这样  先用一个简单变量保存起来
    function search() {
        var location = window.location;
        alert(location.href + location.host);
    }
</code></pre><p>定时器<br>如果针对的是不断运行的代码，不应该使用setTimeout，而应该是用setInterval，因为setTimeout每一次都会初始化一个定时器，而setInterval只会在开始的时候初始化一个定时器</p>
<pre><code>var timeoutTimes = 0;
function timeout() {
    timeoutTimes++;
    if (timeoutTimes &lt; 10) {
        setTimeout(timeout, 10);
    }
}
timeout();
//可以替换为：
var intervalTimes = 0;
function interval() {
    intervalTimes++;
    if (intervalTimes &gt;= 10) {
        clearInterval(interv);
    }
}
var interv = setInterval(interval, 10);
</code></pre><p>字符串连接<br>如果要连接多个字符串，应该少使用+=，如</p>
<p>s+=a;</p>
<p>s+=b;</p>
<p>s+=c;<br>应该写成s+=a + b + c；</p>
<p>而如果是收集字符串，比如多次对同一个字符串进行+=操作的话，最好使用一个缓存，使用JavaScript数组来收集，最后使用join方法连接起来。</p>
<pre><code>var buf = [];
for (var i = 0; i &lt; 100; i++) {
    buf.push(i.toString());
}
var all = buf.join(&quot;&quot;);
</code></pre><p>避免with语句<br>和函数类似 ，with语句会创建自己的作用域，因此会增加其中执行的代码的作用域链的长度，由于额外的作用域链的查找，在with语句中执行的代码肯定会比外面执行的代码要慢，在能不使用with语句的时候尽量不要使用with语句。</p>
<p> with (a.b.c.d) {<br>            property1 = 1;<br>            property2 = 2;<br>        }<br>        //可以替换为：<br>        var obj = a.b.c.d;<br>        obj.property1 = 1;<br>        obj.property2 = 2;<br>数字转换成字符串<br>般最好用”” + 1来将数字转换成字符串，虽然看起来比较丑一点，但事实上这个效率是最高的，性能上来说：</p>
<p>(“” +) &gt; String() &gt; .toString() &gt; new String()<br>浮点数转换成整型<br>很多人喜欢使用parseInt()，其实parseInt()是用于将字符串转换成数字，而不是浮点数和整型之间的转换，我们应该使用Math.floor()或者Math.round()</p>
<p>各种类型转换<br>var myVar = “3.14159”,<br>        str = “” + myVar, //  to string<br>        i_int = ~ ~myVar,  //  to integer<br>        f_float = 1 <em> myVar,  //  to float<br>        b_bool = !!myVar,  /</em>  to boolean - any string with length<br>                                and any number except 0 are true */<br>        array = [myVar];  //  to array<br>如果定义了toString()方法来进行类型转换的话，推荐显式调用toString()，因为内部的操作在尝试所有可能性之后，会尝试对象的toString()方法尝试能否转化为String，所以直接调用这个方法效率会更高</p>
<p>多个类型声明<br>在JavaScript中所有变量都可以使用单个var语句来声明，这样就是组合在一起的语句，以减少整个脚本的执行时间，就如上面代码一样，上面代码格式也挺规范，让人一看就明了。</p>
<p>插入迭代器<br>如var name=values[i]; i++;前面两条语句可以写成var name=values[i++]</p>
<p>使用直接量<br>var aTest = new Array(); //替换为<br>        var aTest = [];<br>        var aTest = new Object; //替换为<br>        var aTest = {};<br>        var reg = new RegExp(); //替换为<br>        var reg = /../;<br>        //如果要创建具有一些特性的一般对象，也可以使用字面量，如下：<br>        var oFruit = new O;<br>        oFruit.color = “red”;<br>        oFruit.name = “apple”;<br>        //前面的代码可用对象字面量来改写成这样：<br>        var oFruit = { color: “red”, name: “apple” };<br>使用DocumentFragment优化多次append<br>一旦需要更新DOM,请考虑使用文档碎片来构建DOM结构，然后再将其添加到现存的文档中。</p>
<p>for (var i = 0; i &lt; 1000; i++) {<br>            var el = document.createElement(‘p’);<br>            el.innerHTML = i;<br>            document.body.appendChild(el);<br>        }<br>        //可以替换为：<br>        var frag = document.createDocumentFragment();<br>        for (var i = 0; i &lt; 1000; i++) {<br>            var el = document.createElement(‘p’);<br>            el.innerHTML = i;<br>            frag.appendChild(el);<br>        }<br>        document.body.appendChild(frag);<br>使用一次innerHTML赋值代替构建dom元素<br>对于大的DOM更改，使用innerHTML要比使用标准的DOM方法创建同样的DOM结构快得多。</p>
<pre><code>var frag = document.createDocumentFragment();
for (var i = 0; i &lt; 1000; i++) {
    var el = document.createElement(&apos;p&apos;);
    el.innerHTML = i;
    frag.appendChild(el);
}
document.body.appendChild(frag);
//可以替换为：
var html = [];
for (var i = 0; i &lt; 1000; i++) {
    html.push(&apos;&lt;p&gt;&apos; + i + &apos;&lt;/p&gt;&apos;);
}
document.body.innerHTML = html.join(&apos;&apos;);
</code></pre><p>通过模板元素clone，替代createElement<br>很多人喜欢在JavaScript中使用document.write来给页面生成内容。事实上这样的效率较低，如果需要直接插入HTML，可以找一个容器元素，比如指定一个div或者span，并设置他们的innerHTML来将自己的HTML代码插入到页面中。通常我们可能会使用字符串直接写HTML来创建节点，其实这样做，1无法保证代码的有效性2字符串操作效率低，所以应该是用document.createElement()方法，而如果文档中存在现成的样板节点，应该是用cloneNode()方法，因为使用createElement()方法之后，你需要设置多次元素的属性，使用cloneNode()则可以减少属性的设置次数——同样如果需要创建很多元素，应该先准备一个样板节点。</p>
<pre><code>var frag = document.createDocumentFragment();
for (var i = 0; i &lt; 1000; i++) {
    var el = document.createElement(&apos;p&apos;);
    el.innerHTML = i;
    frag.appendChild(el);
}
document.body.appendChild(frag);
//替换为：
var frag = document.createDocumentFragment();
var pEl = document.getElementsByTagName(&apos;p&apos;)[0];
for (var i = 0; i &lt; 1000; i++) {
    var el = pEl.cloneNode(false);
    el.innerHTML = i;
    frag.appendChild(el);
}
document.body.appendChild(frag);
</code></pre><p>使用firstChild和nextSibling代替childNodes遍历dom元素<br>图片描述</p>
<pre><code>var nodes = element.childNodes;
for (var i = 0, l = nodes.length; i &lt; l; i++) {
    var node = nodes[i];
    //……
}
//可以替换为：
var node = element.firstChild;
while (node) {
    //……
    node = node.nextSibling;
</code></pre><p>删除DOM节点<br>删除dom节点之前,一定要删除注册在该节点上的事件,不管是用observe方式还是用attachEvent方式注册的事件,否则将会产生无法回收的内存。另外，在removeChild和innerHTML=’’二者之间,尽量选择后者. 因为在sIEve(内存泄露监测工具)中监测的结果是用removeChild无法有效地释放dom节点</p>
<p>使用事件代理<br>任何可以冒泡的事件都不仅仅可以在事件目标上进行处理，目标的任何祖先节点上也能处理，使用这个知识就可以将事件处理程序附加到更高的地方负责多个目标的事件处理，同样，对于内容动态增加并且子节点都需要相同的事件处理函数的情况，可以把事件注册提到父节点上，这样就不需要为每个子节点注册事件监听了。另外，现有的js库都采用observe方式来创建事件监听,其实现上隔离了dom对象和事件处理函数之间的循环引用,所以应该尽量采用这种方式来创建事件监听</p>
<p>重复使用的调用结果，事先保存到局部变量</p>
<pre><code>//避免多次取值的调用开销
var h1 = element1.clientHeight + num1;
var h2 = element1.clientHeight + num2;
//可以替换为：
var eleHeight = element1.clientHeight;
var h1 = eleHeight + num1;
var h2 = eleHeight + num2;
</code></pre><p>注意NodeList<br>最小化访问NodeList的次数可以极大的改进脚本的性能</p>
<pre><code>var images = document.getElementsByTagName(&apos;img&apos;);
for (var i = 0, len = images.length; i &lt; len; i++) {

}
</code></pre><p>编写JavaScript的时候一定要知道何时返回NodeList对象，这样可以最小化对它们的访问</p>
<p>进行了对getElementsByTagName()的调用<br>获取了元素的childNodes属性<br>获取了元素的attributes属性<br>访问了特殊的集合，如document.forms、document.images等等<br>要了解了当使用NodeList对象时，合理使用会极大的提升代码执行速度</p>
<p>优化循环<br>可以使用下面几种方式来优化循环</p>
<p>减值迭代<br>大多数循环使用一个从0开始、增加到某个特定值的迭代器，在很多情况下，从最大值开始，在循环中不断减值的迭代器更加高效</p>
<p>简化终止条件<br>由于每次循环过程都会计算终止条件，所以必须保证它尽可能快，也就是说避免属性查找或者其它的操作，最好是将循环控制量保存到局部变量中，也就是说对数组或列表对象的遍历时，提前将length保存到局部变量中，避免在循环的每一步重复取值。</p>
<pre><code>var list = document.getElementsByTagName(&apos;p&apos;);
for (var i = 0; i &lt; list.length; i++) {
    //……
}

//替换为：
var list = document.getElementsByTagName(&apos;p&apos;);
for (var i = 0, l = list.length; i &lt; l; i++) {
    //……
}
</code></pre><p>简化循环体<br>循环体是执行最多的，所以要确保其被最大限度的优化</p>
<p>使用后测试循环<br>在JavaScript中，我们可以使用for(;;),while(),for(in)三种循环，事实上，这三种循环中for(in)的效率极差，因为他需要查询散列键，只要可以，就应该尽量少用。for(;;)和while循环，while循环的效率要优于for(;;)，可能是因为for(;;)结构的问题，需要经常跳转回去。</p>
<pre><code>var arr = [1, 2, 3, 4, 5, 6, 7];
var sum = 0;
for (var i = 0, l = arr.length; i &lt; l; i++) {
    sum += arr[i];
}

//可以考虑替换为：

var arr = [1, 2, 3, 4, 5, 6, 7];
var sum = 0, l = arr.length;
while (l--) {
    sum += arr[l];
}
</code></pre><p>最常用的for循环和while循环都是前测试循环，而如do-while这种后测试循环，可以避免最初终止条件的计算，因此运行更快。</p>
<p>展开循环<br>当循环次数是确定的，消除循环并使用多次函数调用往往会更快。</p>
<p>避免双重解释<br>如果要提高代码性能，尽可能避免出现需要按照JavaScript解释的字符串，也就是</p>
<p>尽量少使用eval函数<br>使用eval相当于在运行时再次调用解释引擎对内容进行运行，需要消耗大量时间，而且使用Eval带来的安全性问题也是不容忽视的。</p>
<p>不要使用Function构造器<br>不要给setTimeout或者setInterval传递字符串参数</p>
<pre><code>var num = 0;
setTimeout(&apos;num++&apos;, 10);
//可以替换为：
var num = 0;
function addNum() {
    num++;
}
setTimeout(addNum, 10);
</code></pre><p>缩短否定检测<br>       if (oTest != ‘#ff0000’) {<br>            //do something<br>        }<br>        if (oTest != null) {<br>            //do something<br>        }<br>        if (oTest != false) {<br>            //do something<br>        }<br>        //虽然这些都正确，但用逻辑非操作符来操作也有同样的效果：<br>        if (!oTest) {<br>            //do something<br>        }<br>条件分支<br>将条件分支，按可能性顺序从高到低排列：可以减少解释器对条件的探测次数<br>在同一条件子的多（&gt;2）条件分支时，使用switch优于if：switch分支选择的效率高于if，在IE下尤为明显。4分支的测试，IE下switch的执行时间约为if的一半。<br>使用三目运算符替代条件分支<br>        if (a &gt; b) {<br>            num = a;<br>        } else {<br>            num = b;<br>        }<br>        //可以替换为：<br>        num = a &gt; b ? a : b;<br>使用常量<br>重复值：任何在多处用到的值都应该抽取为一个常量<br>用户界面字符串：任何用于显示给用户的字符串，都应该抽取出来以方便国际化<br>URLs：在Web应用中，资源位置很容易变更，所以推荐用一个公共地方存放所有的URL<br>任意可能会更改的值：每当你用到字面量值的时候，你都要问一下自己这个值在未来是不是会变化，如果答案是“是”，那么这个值就应该被提取出来作为一个常量。<br>避免与null进行比较<br>由于JavaScript是弱类型的，所以它不会做任何的自动类型检查，所以如果看到与null进行比较的代码，尝试使用以下技术替换</p>
<p>如果值应为一个引用类型，使用instanceof操作符检查其构造函数<br>如果值应为一个基本类型，作用typeof检查其类型<br>如果是希望对象包含某个特定的方法名，则使用typeof操作符确保指定名字的方法存在于对象上<br>避免全局量<br>全局变量应该全部字母大写，各单词之间用_下划线来连接。尽可能避免全局变量和函数, 尽量减少全局变量的使用，因为在一个页面中包含的所有JavaScript都在同一个域中运行。所以如果你的代码中声明了全局变量或者全局函数的话，后面的代码中载入的脚本文件中的同名变量和函数会覆盖掉（overwrite）你的。</p>
<p>//糟糕的全局变量和全局函数<br>var current = null;<br>function init(){<br>//…<br>}<br>function change() {<br>    //…<br>}<br>function verify() {<br>    //…<br>}<br>//解决办法有很多，Christian Heilmann建议的方法是：<br>//如果变量和函数不需要在“外面”引用，那么就可以使用一个没有名字的方法将他们全都包起来。<br>(function(){<br>var current = null;<br>function init() {<br>    //…<br>}<br>function change() {<br>    //…<br>}<br>function verify() {<br>    //…<br>}<br>})();<br>//如果变量和函数需要在“外面”引用，需要把你的变量和函数放在一个“命名空间”中<br>//我们这里用一个function做命名空间而不是一个var，因为在前者中声明function更简单，而且能保护隐私数据<br>myNameSpace = function() {<br>    var current = null;</p>
<pre><code>function init() {
    //...
}

function change() {
    //...
}

function verify() {
    //...
}
</code></pre><p>//所有需要在命名空间外调用的函数和属性都要写在return里面<br>    return {<br>        init: init,<br>        //甚至你可以为函数和属性命名一个别名<br>        set: change<br>    };<br>};<br>尊重对象的所有权<br>因为JavaScript可以在任何时候修改任意对象，这样就可以以不可预计的方式覆写默认的行为，所以如果你不负责维护某个对象，它的对象或者它的方法，那么你就不要对它进行修改，具体一点就是说：</p>
<p>不要为实例或原型添加属性<br>不要为实例或者原型添加方法<br>不要重定义已经存在的方法<br>不要重复定义其它团队成员已经实现的方法，永远不要修改不是由你所有的对象，你可以通过以下方式为对象创建新的功能:<br>创建包含所需功能的新对象，并用它与相关对象进行交互<br>创建自定义类型，继承需要进行修改的类型，然后可以为自定义类型添加额外功能<br>循环引用<br>如果循环引用中包含DOM对象或者ActiveX对象，那么就会发生内存泄露。内存泄露的后果是在浏览器关闭前，即使是刷新页面，这部分内存不会被浏览器释放。</p>
<p>简单的循环引用：</p>
<pre><code>var el = document.getElementById(&apos;MyElement&apos;);
var func = function () {
    //…
}
el.func = func;
func.element = el;
</code></pre><p>但是通常不会出现这种情况。通常循环引用发生在为dom元素添加闭包作为expendo的时候。</p>
<pre><code>function init() {
    var el = document.getElementById(&apos;MyElement&apos;);
    el.onclick = function () {
        //……
    }
}
init();
</code></pre><p>init在执行的时候，当前上下文我们叫做context。这个时候，context引用了el，el引用了function，function引用了context。这时候形成了一个循环引用。</p>
<p>下面2种方法可以解决循环引用：</p>
<p>1) 置空dom对象</p>
<pre><code>function init() {
     var el = document.getElementById(&apos;MyElement&apos;);
     el.onclick = function () {
         //……
     }
 }
 init();
 //可以替换为：
 function init() {
     var el = document.getElementById(&apos;MyElement&apos;);
     el.onclick = function () {
         //……
     }
     el = null;
 }
 init();
</code></pre><p>将el置空，context中不包含对dom对象的引用，从而打断循环应用。</p>
<p>如果我们需要将dom对象返回，可以用如下方法：</p>
<pre><code>function init() {
    var el = document.getElementById(&apos;MyElement&apos;);
    el.onclick = function () {
        //……
    }
    return el;
}
init();
//可以替换为：
function init() {
    var el = document.getElementById(&apos;MyElement&apos;);
    el.onclick = function () {
        //……
    }
    try {
        return el;
    } finally {
        el = null;
    }
}
init();
</code></pre><p>2) 构造新的context</p>
<pre><code>function init() {
    var el = document.getElementById(&apos;MyElement&apos;);
    el.onclick = function () {
        //……
    }
}
init();
//可以替换为：
function elClickHandler() {
    //……
}
function init() {
    var el = document.getElementById(&apos;MyElement&apos;);
    el.onclick = elClickHandler;
}
init();
</code></pre><p>把function抽到新的context中，这样，function的context就不包含对el的引用，从而打断循环引用。</p>
<p>通过javascript创建的dom对象，必须append到页面中<br>IE下，脚本创建的dom对象，如果没有append到页面中，刷新页面，这部分内存是不会回收的！</p>
<pre><code>function create() {
    var gc = document.getElementById(&apos;GC&apos;);
    for (var i = 0; i &lt; 5000; i++) {
        var el = document.createElement(&apos;div&apos;);
        el.innerHTML = &quot;test&quot;;
        //下面这句可以注释掉，看看浏览器在任务管理器中，点击按钮然后刷新后的内存变化
        gc.appendChild(el);
    }
}
</code></pre><p>释放dom元素占用的内存<br>将dom元素的innerHTML设置为空字符串，可以释放其子元素占用的内存。</p>
<p>在rich应用中，用户也许会在一个页面上停留很长时间，可以使用该方法释放积累得越来越多的dom元素使用的内存。</p>
<p>释放javascript对象<br>在rich应用中，随着实例化对象数量的增加，内存消耗会越来越大。所以应当及时释放对对象的引用，让GC能够回收这些内存控件。</p>
<p>对象：obj = null<br>对象属性：delete obj.myproperty<br>数组item：使用数组的splice方法释放数组中不用的item<br>避免string的隐式装箱<br>对string的方法调用，比如’xxx’.length，浏览器会进行一个隐式的装箱操作，将字符串先转换成一个String对象。推荐对声明有可能使用String实例方法的字符串时，采用如下写法：</p>
<p>var myString = new String(‘Hello World’);<br>松散耦合<br>1、解耦HTML/JavaScript</p>
<p>JavaScript和HTML的紧密耦合：直接写在HTML中的JavaScript、使用包含内联代码的<script>元素、使用HTML属性来分配事件处理程序等</p>
<p>HTML和JavaScript的紧密耦合：JavaScript中包含HTML，然后使用innerHTML来插入一段html文本到页面</p>
<p>其实应该是保持层次的分离，这样可以很容易的确定错误的来源，所以我们应确保HTML呈现应该尽可能与JavaScript保持分离</p>
<p>2、解耦CSS/JavaScript</p>
<p>显示问题的唯一来源应该是CSS，行为问题的唯一来源应该是JavaScript，层次之间保持松散耦合才可以让你的应用程序更加易于维护，所以像以下的代码element.style.color=”red”尽量改为element.className=”edit”，而且不要在css中通过表达式嵌入JavaScript</p>
<p>3、解耦应用程序/事件处理程序</p>
<p>将应用逻辑和事件处理程序相分离：一个事件处理程序应该从事件对象中提取，并将这些信息传送给处理应用逻辑的某个方法中。这样做的好处首先可以让你更容易更改触发特定过程的事件，其次可以在不附加事件的情况下测试代码，使其更易创建单元测试</p>
<p>性能方面的注意事项<br>1、尽量使用原生方法</p>
<p>2、switch语句相对if较快</p>
<p>通过将case语句按照最可能到最不可能的顺序进行组织</p>
<p>3、位运算较快</p>
<p>当进行数字运算时，位运算操作要比任何布尔运算或者算数运算快</p>
<p>4、巧用||和&amp;&amp;布尔运算符</p>
<pre><code>function eventHandler(e) {
    if (!e) e = window.event;
}
//可以替换为：
function eventHandler(e) {
    e = e || window.event;
}
if (myobj) {
    doSomething(myobj);
}
//可以替换为：
myobj &amp;&amp; doSomething(myobj);
</code></pre><p>避免错误应注意的地方<br>1、每条语句末尾须加分号</p>
<p>在if语句中，即使条件表达式只有一条语句也要用{}把它括起来，以免后续如果添加了语句之后造成逻辑错误</p>
<p>2、使用+号时需谨慎</p>
<p>JavaScript 和其他编程语言不同的是，在 JavaScript 中，’+’除了表示数字值相加，字符串相连接以外，还可以作一元运算符用，把字符串转换为数字。因而如果使用不当，则可能与自增符’++’混淆而引起计算错误</p>
<pre><code>var valueA = 20;
var valueB = &quot;10&quot;;
alert(valueA + valueB);     //ouput: 2010 
alert(valueA + (+valueB));  //output: 30 
alert(valueA + +valueB);    //output:30 
alert(valueA ++ valueB);     //Compile error
</code></pre><p>3、使用return语句需要注意</p>
<p>一条有返回值的return语句不要用()括号来括住返回值，如果返回表达式，则表达式应与return关键字在同一行，以避免压缩时，压缩工具自动加分号而造成返回与开发人员不一致的结果</p>
<pre><code>function F1() {
    var valueA = 1;
    var valueB = 2;
    return valueA + valueB;
}
function F2() {
    var valueA = 1;
    var valueB = 2;
    return
    valueA + valueB;
}
alert(F1());  //output: 3 
alert(F2());  //ouput: undefined
</code></pre><p>==和===的区别<br>避免在if和while语句的条件部分进行赋值，如if (a = b)，应该写成if (a == b)，但是在比较是否相等的情况下，最好使用全等运行符，也就是使用===和!==操作符会相对于==和!=会好点。==和!=操作符会进行类型强制转换</p>
<pre><code>var valueA = &quot;1&quot;;
var valueB = 1;
if (valueA == valueB) {
    alert(&quot;Equal&quot;);
}
else {
    alert(&quot;Not equal&quot;);
}
//output: &quot;Equal&quot;
if (valueA === valueB) {
    alert(&quot;Equal&quot;);
}
else {
    alert(&quot;Not equal&quot;);
}
//output: &quot;Not equal&quot;
</code></pre><p>不要使用生偏语法</p>
<ul>
<li>不要使用生偏语法，写让人迷惑的代码，虽然计算机能够正确识别并运行，但是晦涩难懂的代码不方便以后维护</li>
</ul>
<p>函数返回统一类型<br>虽然JavaScript是弱类型的，对于函数来说，前面返回整数型数据，后面返回布尔值在编译和运行都可以正常通过，但为了规范和以后维护时容易理解，应保证函数应返回统一的数据类型</p>
<p>总是检查数据类型<br>要检查你的方法输入的所有数据，一方面是为了安全性，另一方面也是为了可用性。用户随时随地都会输入错误的数据。这不是因为他们蠢，而是因为他们很忙，并且思考的方式跟你不同。用typeof方法来检测你的function接受的输入是否合法</p>
<p>何时用单引号，何时用双引号</p>
<ul>
<li>虽然在JavaScript当中，双引号和单引号都可以表示字符串, 为了避免混乱，我们建议在HTML中使用双引号，在JavaScript中使用单引号，但为了兼容各个浏览器，也为了解析时不会出错，定义JSON对象时，最好使用双引号</li>
</ul>
<h3 id="部署"><a href="#部署" class="headerlink" title="部署"></a>部署</h3><p>用JSLint运行JavaScript验证器来确保没有语法错误或者是代码没有潜在的问<br>部署之前推荐使用压缩工具将JS文件压缩<br>文件编码统一用UTF-8</p>
<ul>
<li>JavaScript 程序应该尽量放在 .js 的文件中，需要调用的时候在 HTML 中以 <script src=”filename.js”> 的形式包含进来。JavaScript 代码若不是该 HTML 文件所专用的，则应尽量避免在 HTML文件中直接编写 JavaScript 代码。因为这样会大大增加 HTML 文件的大小，无益于代码的压缩和缓存的使用。另外，<script src=”filename.js”> 标签应尽量放在文件的后面,最好是放在</body>标签前。这样会降低因加载 JavaScript 代码而影响页面中其它组件的加载时间。</li>
<li>永远不要忽略代码优化工作，重构是一项从项目开始到结束需要持续的工作，只有不断的优化代码才能让代码的执行效率越来越好。</li>
</ul>
<p>文章源自：<a href="http://www.cnblogs.com/elegance/p/4288435.html">http://www.cnblogs.com/elegance/p/4288435.html</a><br>相关标签：JavaScript</p>
</script></p>
      
    </div>
    
    <div class="article-info article-info-index">
      
      

      
      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>









  
    <article id="post-前端兼容" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2017/05/31/前端兼容/" class="article-date">
      <time datetime="2017-05-31T06:51:25.818Z" itemprop="datePublished">2017-05-31</time>
</a>


    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
    <div class="article-entry" itemprop="articleBody">
      
          
        <ul>
<li>页面乱的原因是因为IE6认为一个DIV超宽了，所以把本应float;right的DIV挤了下去。而如果设置为IE6下显示正常的宽度，则在IE7和Firefox下看页面就会少了一块一样，也很别扭。</li>
</ul>
<ul>
<li>用CSS HACK 来改写CSS代码    <blockquote>
<p> 改写前：xxx. yyy:{width:600px;} </p>
<p> (当设为IE7和Firefox下显示正常的600px时    ，IE6下会错位，改为590px，则IE6下正常，IE7和Firefox下显示不完美) </p>
<p>  改写后： xxx. yyy{width:600px; <em> width:600px; _ width:590px;}<br>  （Firefox不认识 </em> 和<em>，而IE都认识 *，IE7不支持 </em> ，IE6支持<em> ）   顺序千万不要乱，因为当出现重复定义时，浏览器默认按最后一下渲染，所以一    定要先正常，再 *，最后 </em> 。   </p>
<p>  这样Firefox读取时只看到了正常的定义，而IE都能看到第二个 <em> 的定义，于是忽    略第一个正常的定义，而IE中因为IE7不再支持_，所以按照第一个带 </em> 号的执行，IE6支持_，所    以认为带*后的也是重复定义，予以忽略，执行最后一个定义。   </p>
<p>   有人喜欢用!important来进行CSS HACK，但我觉得!important写起来太长了，不    如 <em> 和_简单直观。    只要记住IE7= </em>，IE6= _ ，然后按照先Firefox后IE7，最后IE6的顺序进行编写，    一般就可以保证大部分用户浏览正常了。</p>
</blockquote>
</li>
</ul>
<ul>
<li>IE下很多地方可以省略一些层定义的浮动属性,但是FF不行,必须每个个层都写清楚,几个DIV层水    平排列的时候,IE6中必须要加display:inline;,不然前端会出现双倍间距,而FF中则加不加    display都显示正常.这些都是由浏览器默认值的不同而引起的,你看到那些大站的布局在各浏览    器中都显示正常,是因为他们把这些默认有区别的地方都定义清楚了.    下面的兼容要点引自互联网    CSS对浏览器的兼容性具有很高的要求，通常情况下IE和Firefox(简称FF)存在很大的解析差异，    </li>
</ul>
<ul>
<li>常见的兼容问题：   </li>
</ul>
<blockquote>
<p> 1.DOCTYPE影响CSS处理<br>     2.FireFox火狐: div设置margin-left,margin-right为auto时已经居中,IE不行<br>     3.FireFox火狐: body设置text-align时,div需要设置margin:auto(主要是margin-left,margin-    right)方可居中<br>     4.FireFox火狐:设置padding后,div会增加height和width,但IE不会,故需要用!important多设一    个height和width<br>     5.FireFox火狐:支持!important,IE则忽略,可用!important为FireFox火狐特别设置样式<br>     6.div的垂直居中问题:vertical-align:middle;将行距增加到和整个DIV一样高line-    height:200px;然后插入文字，就垂直居中了。缺点是要控制内容不要换行<br>     7.cursor:pointer可以同时在IEFireFox火狐中显示游标手指状，hand仅IE可以<br>     8.FireFox火狐:链接加边框和背景色，需设置display:block,同时设置float:left保证不换行。    参照menubar,给a和menubar设置高度是为了避免底边显示错位,若不设height,可以在menubar中    插入一个空格。<br>     9.在mozillafirefox和IE中的BOX模型解释不一致导致相差2px解决方法：  div{margin:30px!important;margin:28px;}   注意这两个margin的顺序一定不能写反，据阿捷的说法!important这个属性IE不能识别，但别的    浏览器可以识别。所以在IE下其实解释成这样：  div{maring:30px;margin:28px}   重复定义的话按照最后一个来执行，所以不可以只写margin:XXpx!important;<br>    10.IE5和IE6的BOX解释不一致 IE5下<br>    div{width:300px;margin:0 10px 0 10px;}<br>    div的宽度会被解释为300px-10px(右填充)-10px(左填充)最终div的宽度为280px，adding:0;}就能解决大部分问题  html,body,div,ul,ol,li,dl,dt,dd,h1,h2,h3,h4,h5,h6,pre,form,p,blockquote,fieldset,input { margin: 0; padding: 0; }  </p>
</blockquote>
<p>*h1,h2,h3,h4,h5,h6,pre,code,address,caption,cite,code,em,strong,th { font-size: 1em; font-weight: normal; font-style: normal; } ………… </p>
<p> 这段代码就很好的诠释了我上面矛盾的话，或许你现在暂时不知道它的用处，但你研究之后就会发现很有意思。  上面这段代码几乎是我们每次编写过程中都要接触和更改的内容，既然每次都一样重复的工作，为什么不提前就准备好呢。先不说设计一套属于自己的CSS框架，哪管把上面的内容放在一个记事本里，用的时候复制进去都比重新写，快乐，轻松，有效率的多。这样的代码不止这些，更多的你可以自己的总结，发现，那样比较有乐趣。  既然要提到效率，不得不提到CSS框架的善用，合理利用。像Blueprint CSS，雅虎的YUI，Elements CSS Frameworks等等，你花多少时间去理解它们都行，不要担心这是无用的分析过程，之后你会提高很多。万变不离其宗，当你把CSS框架搭好，剩下的，只是每次布局上的变动，和细微处的调节过程，而不再是一切从0开始……  在百度知道上我曾经说早先用IEtest的时候有BUG，当时被人一顿埋汰……  我好多同学，同时用了很久的是Multiple IEs，他们都说是用过最稳定的一款软件。但遗憾的是直到现在，官方也没有更新过，仍然停留在IE6而已。不过你们不防用用试试。  关于BUG和CSS HACK。不知道你接触过IE6以下的版本没有，那些，才是所谓的BUG，另人莫名其妙的BUG，每次编写前需要先修订这些BUG。目前来说，个人觉得没有什么BUG可言。  至于CSS HACK，凡是有经验的人都知道善用而不是滥用。我觉得它更像一块补丁，如果你自己裁剪衣服没裁剪好，而想着用后期用补丁修补，这和亡羊补牢没什么区别。 最开始就应该打下坚实的基础我始终坚信，在编写的代码符合嵌套规则，语义化，符合WEB标准的前提下，你把代码放在裤裆里显示，浏览器之间的差异也不会太大。只有当自己的代码不符合标准的时候，才会出现各种差异。  最注意的是，当差异很小的时候，不要太追求完美，严谨，过的去就可以，花3，4行代码去修正1像素的差异，得不偿失*。</p>

      
    </div>
    
    <div class="article-info article-info-index">
      
      

      
      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>









  
    <article id="post-前端面试问题" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2017/05/19/前端面试问题/" class="article-date">
      <time datetime="2017-05-19T08:16:17.951Z" itemprop="datePublished">2017-05-19</time>
</a>


    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
    <div class="article-entry" itemprop="articleBody">
      
          
        <h3 id="前端面试题："><a href="#前端面试题：" class="headerlink" title="前端面试题："></a>前端面试题：</h3><p>HTML与XHTML——二者有什么区别</p>
<pre><code>XHTML 元素必须被正确地嵌套
XHTML 元素必须被关闭，空标签也必须被关闭，如 &lt;br&gt; 必须写成 &lt;br /&gt;
XHTML 标签名必须用小写字母
XHTML 文档必须拥有根元素
XHTML 文档要求给所有属性赋一个值
XHTML 要求所有的属性必须用引号&quot;&quot;括起来
XHTML 文档需要把所有 &lt; 、&gt;、&amp; 等特殊符号用编码表示
XHTML 文档不要在注释内容中使“--”
XHTML 图片必须有说明文字
XHTML 文档中用id属性代替name属性
</code></pre><p> 代码</p>
<pre><code>&lt;!DOCTYPE html&gt;
&lt;html&gt;
    &lt;head&gt;
      &lt;meta charset=&quot;utf-8&quot;&gt;
      &lt;title&gt;Backbone Demo&lt;/title&gt;
    &lt;/head&gt;
    &lt;body&gt;

    &lt;h1&gt;Backbone Routing Demo&lt;/h1&gt;

      &lt;ul id=&quot;menu&quot;&gt;
        &lt;li&gt;&lt;a href=&quot;#&quot;&gt;Index&lt;/a&gt;&lt;&gt;
        &lt;li&gt;&lt;a href=&quot;#show/1&quot;&gt;Show&lt;/a&gt;&lt;&gt;
        &lt;li&gt;&lt;a href=&quot;#download/1&quot;&gt;Download&lt;/a&gt;&lt;&gt;
        &lt;li&gt;&lt;a href=&quot;#search/1&quot;&gt;Search&lt;/a&gt;&lt;&gt;
        &lt;li&gt;&lt;a href=&quot;#other&quot;&gt;Other&lt;/a&gt;&lt;&gt;
      &lt;/ul&gt;

    &lt;script src=&quot;js/underscore.js&quot;&gt;&lt;/script&gt;
    &lt;script src=&quot;js/jquery.js&quot;&gt;&lt;/script&gt;
    &lt;script src=&quot;js/backbone.js&quot;&gt;&lt;/script&gt;
    &lt;script src=&quot;js/main.js&quot;&gt;&lt;/script&gt;

&lt;/body&gt;
</code></pre><p>一、有接触过后端语言么？谈谈你前后端的理解？</p>
<blockquote>
<p>1.接触过，php，技术体系是wamp - windows apache mysql php</p>
<p>2.前端与后端两者的关系：前端负责收集和呈现数据，后端负责处理和存储数据</p>
<p>3.对前后端分离的理解：比如 mvc，数据给 m 层处理，业务让 c 层控制，模版由 v 层管理。在写代码的时候，前后端工程师分工清楚，协同开发效率高，系统业务关系明确。</p>
</blockquote>
<p>二、前端与后端工程师配合工作，主要在哪些方面？</p>
<blockquote>
<p>1.前端给后端数据：form提交、ajax的data数据提交</p>
<p>2.后端给前端数据：ajax的success返回、框架自带的模版引擎做数据渲染</p>
</blockquote>
<p>三、何为同源，何为跨域？</p>
<blockquote>
<p>1.同源：协议-主机-端口，三者都相同，为同源</p>
<p>2.跨域：上述上个，有一个不同，则为跨域</p>
</blockquote>
<p>四、跨域传输数据，有什么方式？或者说由前端还是后端解决？</p>
<blockquote>
<p>1.后端处理方法：设置权限，允许所有域名通过，比如 header(‘Access-Control-Allow-Origin:*’);</p>
<p>2.前端处理方法：jsonp、web-sockets、cors、iframe</p>
<p>3.参考文章：<a href="https://segmentfault.com/q/1010000006250875?_ea=1072719" target="_blank" rel="external">https://segmentfault.com/q/1010000006250875?_ea=1072719</a> <a href="https://github.com/rccoder/blog/issues/5" target="_blank" rel="external">https://github.com/rccoder/blog/issues/5</a></p>
</blockquote>
<p>五、一个较为完整的 ajax 例子，以及ajax各个参数的意思？</p>
<ol>
<li>看下图</li>
</ol>
<p><img src="http://i.imgur.com/2tI7Wxi.png" alt=""></p>
<ol>
<li>另外参考 <a href="http://www.w3school.com.cn/jquery/ajax_ajax.asp" target="_blank" rel="external">http://www.w3school.com.cn/jquery/ajax_ajax.asp</a></li>
</ol>
<p>六.form中的input可以设置为readonly和disable，请问2者有什么区别？</p>
<pre><code>readonly是为只读, input框value值用户不可修改。

disable:是为禁用，input框不可用,用户不可点击。
</code></pre><p>七.希望获取到页面中所有的checkbox怎么做？</p>
<p><code>&lt;script&gt;
        var oCh = $(&#39;:checkbox&#39;);
    &lt;/script&gt;</code></p>
<p>八.解释一下ajax，分析其优缺点</p>
<blockquote>
<pre><code>ajax是 Asynchhronous JavaScript and XML的缩写，异步的js和XML
ajax通过XMLHttpRequest对象向服务器发送异步请求来进行数据交互
</code></pre></blockquote>
<pre><code>ajax的优点是：
1.局部动态刷新；不需要整个页面的刷新，提升用户体验；
2.异步的通信方式，不需要打断用户操作，响应迅速，较少数据传输
3.前后端负载平衡，按需读取，减轻服务器负担，提升网站性能
4.ajax被广泛支持
5.数据与视图分离，符合前端表现行为分离的设计思想
缺点：
1.不支持跨域，需要通过jsonP/cors等方法实现跨域请求
2.对浏览器前进后退机制的破坏
3.对搜索引擎支持较弱（数据和dom是动态生成的）
4.安全问题，容易遭受攻击
</code></pre><p>九.判断对错：<br>（1）null是一个只有一个值的数据类型，这个值就是null。( √ )</p>
<p>（2）Undefined是一个只有一个值的数据类型，这个值就是“undefined”。( √ )</p>
<p>十.已知数组var arr = [“This”, “is”, “A”, “Dog”]，要求Alert出”This is A Dog”。</p>
<blockquote>
<p>`<body><br>        <script><br>            var arr = [“This”, “is”, “A”, “Dog”]<br>            var ar = arr.join(‘ ‘)<br>            alert(ar)<br>        </script><br>    </body>``</p>
</blockquote>
<p>十一.获取并输出今天的日期，以YYYY-MM-DD的方式，比如今天是2017年3月14日，则输出2017-05-08。</p>
<pre><code>&lt;script type=&quot;text/javascript&quot;&gt;
    var oDate = new Date();

    var year = oDate.getFullYear()
    var mon    = oDate.getMonth()+1 ;
    var date = oDate.getDate();

    function ti (n1){
        if(n1 &lt;10){
            return &quot;0&quot; +n1;
        }else{
            return &quot;&quot; + n1;
    }
    }
    console.log(ti(year) + &apos;-&apos; + ti(mon) + &apos;-&apos;+ ti(date) )
&lt;/script&gt;
</code></pre><p>十二.foo = foo||bar ，这行代码是什么意思？为什么要这样写？</p>
<blockquote>
<pre><code>短路表达式，如果foo存在，则把foo的值赋给foo变量，否则把bar值赋给foo；
foo和bar都是bool型变量,只要foo或者bar有一个为真，那么这个表达式的值就为真，并把它赋给foo。
</code></pre></blockquote>
<p>十三.下面的代码输出什么，为什么，请解释原理？</p>
<pre><code>`var foo = 1;
    function fn1(){
        console.log(foo);
        var foo = 2;
        console.log(foo);
    }
    fn1();`
</code></pre><blockquote>
<p>结果：undefined , 2;<br>    原理：undefined,因为函数内的varfoo把外头的给覆盖了。相当于有一个 var foo;在一个函数内任何地方声明的var都会被提到函数的最开头。</p>
</blockquote>
<p>十四.如何垂直居中一个</p>
<pre><code>&lt;!DOCTYPE html&gt;
&lt;html&gt;
&lt;head&gt;
&lt;title&gt;&lt;/title&gt;
    &lt;style type=&quot;text/css&quot;&gt;
        .div{
            width: 500px;
            height: 500px;
            border:1px solid #000;
            text-align: center;
            display: table-cell;
            vertical-align: middle;
        }
        .div img{
            vertical-align: middle;
        }
    &lt;/style&gt;
    &lt;/head&gt;
    &lt;body&gt;
    &lt;div class=&apos;div&apos;&gt;
        &lt;img src=&quot;xiong.jpg&quot;&gt;
    &lt;/div&gt;
&lt;/body&gt;
&lt;/html&gt;
</code></pre><p>十五.什么叫做事件委托，事件委托的优势是什么</p>
<blockquote>
<p>事件委托就是利用事件冒泡，只指定一个事件处理程序，就可以管理某一类型的所有事件。<br>        优势：1、减少dom的操作，提高性能。<br>              （1）减少事件注册，节省内存。<br>                  （2）简化了dom节点更新时，相应事件的更新。</p>
</blockquote>
<p>十六.alert() 输出 ①换行 ② </p>
<pre><code>alert(&quot;a\nb&quot;);
alert(&quot;&lt;\/script&gt;&quot;)
</code></pre><p>十七.== 与 === 的区别？</p>
<blockquote>
<p>前者一个是判断值是否相等,后者一个是判断值及类型是否完全相等。<br>        其中第一个在比较的时候，会进行类型转换，而第二个则不会</p>
</blockquote>
<p>十八.写出不少于5种Math对象的方法，分别说明含义以及用法</p>
<pre><code>Math.random()
1,方法返回带正号的 double值，该值大于等于0.0且小于1.0，如果先强制转换类型为int的话，返回为0，那么第二个始终返回为1
2,Math.random()*14 //会返回一个 0-14 之间的随机数。

Math.floor()
1,方法执行的是向下取整计算，它返回的是小于或等于函数参数，并且与之最接近的整数。
2,Math.floor(12.2)//返回12.0。

Math.ceil()
1,方法可将小数部分一律向整数部分进位。
2,Math.ceil(12.2)//返回13.0。

Math.round() 
1,方法可把一个数字舍入为最接近的整数。
2,Math.round(12.2)//返回12.0。

Math.max() 
1,方法用来获取给定的一组数值中的最大值。
2,var arr = [2, 4, 6, 8, 5, 0]; 
  var m=Math.max(arr);得到最大值8。
</code></pre><p>十九.使用任意一种方法随机生成一个从100-300的整数</p>
<pre><code>&lt;body&gt;
    &lt;input id=&apos;btn&apos; type=&quot;button&quot; name=&quot;&quot; value=&apos;随机生成&apos;&gt;
    &lt;span id=&apos;sp&apos;&gt;&lt;/span&gt;
    &lt;script type=&quot;text/javascript&quot;&gt;
        var oBtn = document.getElementById(&apos;btn&apos;);
        var oSp = document.getElementById(&apos;sp&apos;);

        function mynumber(Num1, Num2) {
            var choice = Num1 - Num2 + 1 ;
            return Math.floor(Math.random() * choice + Num2)
        }
        oBtn.onclick = function () {
            oSp.innerHTML = mynumber(300,100); 
        }

    &lt;/script&gt;
&lt;/body&gt;
</code></pre><p>二十.window load 和document ready的区别</p>
<blockquote>
<p>load表示，内容和dom都加载完成时在执行里面的代码。<br>        ready是，dom加载完就执行里面的代码。<br>        load在一个页面中如果有多次出现，只取最后一次。ready多次出现都可以</p>
</blockquote>
<p>二一.解释jsonp的原理，以及为什么jsonp不是真正的ajax</p>
<pre><code>JSONP是一种非正式传输协议，该协议的一个要点就是允许用户传递一个callback参数给服务端，然后服务端返回数据时会将这个callback参数作为函数名来包裹住JSON数据，这样客户端就可以随意定制自己的函数来自动处理返回数据了
实现方法完全不一样。ajax的核心是通过XmlHttpRequest获取非本页内容，而jsonp的核心则是动态添加标签来调用服务器提供的js脚本。

（1）jsonp是前端工程师用来解决跨域的技术方案
（2）jsonp的原理，是通过callback参数给服务器端，然后服务端返回数据时会将这个callback参数作为函数    名来包裹住JSON数据
（3）ajax和jsonp不同，ajax用的是xmlHttpRequest技术，jsonp用的是callback参数作为函数名来包裹住JSO    N数据
</code></pre><p>二二.常用浏览器内核</p>
<ol>
<li>webkit(Safari、Chrome) </li>
<li>gecko(Mozilla Firefox)</li>
<li>Trident(IE内核)</li>
<li>Presto(Opera)</li>
<li>blink(chromium)</li>
</ol>
<p>二三.img标签上title与alt属性的区别是什么?</p>
<blockquote>
<p>alt表示_图片加载失败时候的替代文字</p>
<p>title表示鼠标悬停在图片上显示出的标题文字</p>
</blockquote>
<p>二四.JavaScript中如何对一个对象进行深度clone</p>
<pre><code>&lt;script&gt;
    function cloneObj(oldObj){
        var str=Json.stringify(oldObj);
        var newObj=Json.parse(str);
        return newObj;
    }

    function cloneObj2(oldObj){
        var newObj={};
        for(var i in oldObj){
            if(typeof oldObj[i]==&apos;object&apos;){
                newObj[i]=cloneObj2(oldObj);
            }else{
                newObj[i]=oldObj[i];
            }
        }
        return newObj;
    }
&lt;/script&gt;
</code></pre><p>二五.简述js同步和异步的区别</p>
<blockquote>
<p>  (1)同步加载又称为阻塞模式，会阻止浏览器的后续处理，js默认为同步执行。</p>
<p>  待数据，返回才会执行下面的代码。</p>
<p> （2）异步模式就是在下载执行js时，还可以继续进行后续页面的处理。</p>
<p>（3）ajax 同步指的是随着网页刷新更改页面内容；异步指的是更改网页局部内容，</p>
<p>不必刷新整个网页；</p>
</blockquote>
<p>二六.什么叫优雅降级和渐进增强？</p>
<blockquote>
<p>渐进增强：针对低版本浏览器进行构建页面，保证最基本的功能，然后再针对高级浏览器进行效<br>果、交互等改进和追加功能达到更好的用户体验。</p>
<p>优雅降级 ：一开始就构建完整的功能，然后再针对低版本浏览器进行兼容。</p>
<p>区别：a. 优雅降级是从复杂的现状开始，并试图减少用户体验的供给;<br>b. 渐进增强则是从一个非常基础的，能够起作用的版本开始，并不断扩充，以适应未来环境的需要;<br>c. 降级（功能衰减）意味着往回看；而渐进增强则意味着朝前看，同时保证其根基处于安全地带;</p>
</blockquote>
<p>二七.一次完整的HTTP事务是怎样的一个过程，常见的状态码有哪些？</p>
<blockquote>
<p>1,域名解析 –2,发起TCP的3次握手 –3,建立TCP连接后发起http请求 –4,服务器响应http请求，浏览器得到html代码 –5,浏览器解析html代码，并请求html代码中的资源（如js、css、图片等） –6,浏览器对页面进行渲染呈现给用户</p>
</blockquote>
<pre><code>常见HTTP状态码:
    200 OK         
        一切正常，对GET和POST请求的应答文档跟在后面
    301 Moved Permanently
        客户请求的文档在其他地方，新的URL在Location头中给出，浏览器应该自动地访问新的URL。
    302 Found
        类似于301，但新的URL应该被视为临时性的替代，而不是永久性的。
    304 Not Modified
       客户端有缓冲的文档并发出了一个条件性的请求（一般是提供If-Modified-Since头表示客户只想比指定日期更新的文档）。服务器告诉客户，原来缓冲的文档还可以继续使用。
    307 Temporary Redirect
        和302（Found）相同。许多浏览器会错误地响应302应答进行重定向，即使原来的请求是 POST，即使它实际上只能在POST请求的应答是303时才能重定向。由于这个原因，HTTP 1.1新增了307，以便更加清除地区分几个状态代码： 当出现303应答时，浏览器可以跟随重定向的GET和POST请求；如果是307应答，则浏览器只能跟随对GET请求的重定向。
    400 Bad Request
       请求出现语法错误。
    401 Unauthorized
       客户试图未经授权访问受密码保护的页面。应答中会包含一个WWW-Authenticate头，浏览器据此显示用户名字/密码对话框，然后在填写合适的Authorization头后再次发出请求。
    403 Forbidden
       资源不可用。
    404 Not Found
         无法找到指定位置的资源
    410 Gone
         所请求的文档已经不再可用，而且服务器不知道应该重定向到哪一个地址。它和404的不同在于，返回407表示文档永久地离开了指定的位置，而404表示由于未知的原因文档不可用。
    500 Internal Server Error
          服务器遇到了意料不到的情况，不能完成客户的请求
    501 Not Implemented
         服务器不支持实现请求所需要的功能。例如，客户发出了一个服务器不支持的PUT请求
    503 Service Unavailable
        临时的服务器维护或者过载，服务器当前无法处理请求。
    504 Gateway Timeout
        作为网关或者代理工作的服务器尝试执行请求时，未能及时从上游服务器
</code></pre><p>二八.CDN是啥？</p>
<blockquote>
<p>CDN的全称是Content Delivery Network，即内容分发网络。<br>        1，CDN是构建在网络之上的内容分发网络，依靠部署在各地的边缘服务器，通过中心平台的负载均衡、内容分发、调度等功能模块，使用户就近获取所需内容，降低网络拥塞，提高用户访问响应速度和命中率。CDN的关键技术主要有内容存储和分发技术。</p>
<p>2，CDN的基本原理是广泛采用各种缓存服务器，将这些缓存服务器分布到用户访问相对集中的地区或网络中，在用户访问网站时，利用全局负载技术将用户的访问指向距离最近的工作正常的缓存服务器上，由缓存服务器直接响应用户请求。</p>
</blockquote>
<p>二九.简述移动开发的注意点,如何做好不同手机的适配,你以前的项目是怎么做的?</p>
<pre><code>`注意点：
一、关于单位的使用
二、布局上换算成rem单位
三、细节处理
    1、禁止自动识别电话和android自动识别邮箱
    2、使用无衬线字体
    3、禁止选择文本
    4、禁止长按链接与图片弹出菜单
    5、去除A连接input标签,点击出现自带的阴影样式
    6、屏蔽阴影
    7、单击延迟
    8、手机拍照和上传图片。

使用不同的响应操作：如，媒体查询Media Queries

&lt;link href=&quot;css/reset.css&quot; rel=&quot;stylesheet&quot; type=&quot;text/css&quot; media=&quot;screen&quot; /&gt;
  &lt;link href=&quot;css/style.css&quot; rel=&quot;stylesheet&quot; type=&quot;text/css&quot; media=&quot;all&quot; /&gt;
  &lt;link href=&quot;css/print.css&quot; rel=&quot;stylesheet&quot; type=&quot;text/css&quot; media=&quot;print&quot; /&gt;`
</code></pre><p>三十.MVC，MVP 和 MVVM </p>
<pre><code>  MVC（Model-View-Controller）是最常见的软件架构之一，业界有着广泛应用。
1.MVC模式的意思是，软件可以分成三个部分。
    视图（View）：用户界面。
    控制器（Controller）：业务逻辑
    模型（Model）：数据保存

       View 传送指令到 Controller
       Controller 完成业务逻辑后，要求 Model 改变状态
    Model 将新的数据发送到 View，用户得到反馈
2、互动模式
    接受用户指令时，MVC 可以分成两种方式。一种是通过 View 接受指令，传递给 Controller。
    另一种是直接通过controller接受指令。
    Backbone
    1. 用户可以向 View 发送指令（DOM 事件），再由 View 直接要求 Model 改变状态。
    2. 用户也可以直接向 Controller 发送指令（改变 URL 触发 hashChange 事件），再由 Controller 发送给 View。
    3. Controller 非常薄，只起到路由的作用，而 View 非常厚，业务逻辑都部署在 View。所以，Backbone 索性取消了 Controller，只保留一个 Router（路由器） 。

MVP 模式将 Controller 改名为 Presenter，同时改变了通信方向。
1. 各部分之间的通信，都是双向的。
2. View 与 Model 不发生联系，都通过 Presenter 传递。
3. View 非常薄，不部署任何业务逻辑，称为&quot;被动视图&quot;（Passive View），即没有任何主动性，而 Presenter非常厚，所有逻辑都部署在那里。    

MVVM 模式将 Presenter 改名为 ViewModel，基本上与 MVP 模式完全一致。
1.唯一的区别是，它采用双向绑定（data-binding）：View的变动，自动反映在 ViewModel，反之亦然。Angular 和 Ember 都采用这种模式。
</code></pre><p>三十一.简述一下你对HTML语义化的理解？并写出一段语义化的HTML？</p>
<pre><code>&gt; 语义化是指根据内容的结构化（内容语义化），选择合适的标签（代码语义化），便于开发者阅读和写出更优雅的代码的同时，让浏览器的爬虫和机器很好的解析。
&gt;用正确的标签做正确的事情
&gt;html语义化让页面的内容结构化，结构更清晰，便于对浏览器、搜索引擎解析
&gt;语义化的HTML在没有CSS的情况下也能呈现较好的内容结构与代码结构
&gt;搜索引擎的爬虫也依赖于HTML标记来确定上下文和各个关键字的权重，利于SEO;
&gt;使阅读源代码的人对网站更容易将网站分块，便于阅读维护理解
&gt;HTML5增加了许多语义化标签如:header footer nav article ……
</code></pre><p>语义化HTML示例：</p>
<pre><code>&lt;!-- 这是开放的 --&gt;
&lt;header&gt;
&lt;h1&gt;header&lt;/h1&gt;
&lt;/header&gt;
&lt;section class=&quot;main&quot;&gt;
  main
&lt;/section&gt;
&lt;aside&gt;aside&lt;/aside&gt;
&lt;footer&gt;
  footer
&lt;/footer&gt;
</code></pre><ol>
<li>HTML5有哪些新特性、移除了那些元素？如何处理HTML5新标签的浏览器兼容问题？如何区分 HTML 和 HTML5？</li>
</ol>
<blockquote>
<p>HTML5 是定义 HTML 标准的最新的版本。 该术语表示两个不同的概念：<br>    它是一个新版本的HTML语言，具有新的元素，属性和行为，<br>    它有更大的技术集，允许更多样化和强大的网站和应用程序。这个集合有时称为HTML5和朋友，通常缩写为HTML5。</p>
</blockquote>
<p>HTML5新特性：</p>
<pre><code>HTML5 现在已经不是 SGML 的子集，主要是关于图像，位置，存储，多任务等功能的增加
绘画 canvas;
用于媒介回放的 video 和 audio 元素;
本地离线存储 localStorage 长期存储数据，浏览器关闭后数据不丢失
sessionStorage 的数据在浏览器关闭后自动删除
语意化更好的内容元素，比如 article、footer、header、nav、section
表单控件，calendar、date、time、email、url、search
新的技术webworker, websocket, Geolocation
移除元素：

纯表现的元素basefont ，big，center，font, s，strike，tt，u
对可用性产生负面影响的元素：frame，frameset，noframes
</code></pre><p>处理HTML5新标签的浏览器兼容问题：</p>
<pre><code>IE8/IE7/IE6支持通过document.createElement方法产生的标签，可以利用这一特性让这些浏览器支持HTML5新标签，浏览器支持新标签后，还需要添加标签默认的样式。

可直接使用成熟的框架、比如html5shiv

&lt;!--[if lt IE 9]&gt;
   &lt;script src=&quot;html5shiv.js&quot;&gt;&lt;/script&gt;
&lt;![endif]--&gt;
</code></pre><p>如何区分 HTML 和 HTML5:</p>
<pre><code>DOCTYPE声明
新增元素
</code></pre><ol>
<li>为什么要初始化CSS样式(reset css)？</li>
</ol>
<blockquote>
<p>因为浏览器的兼容问题，不同浏览器对有些标签的默认值是不同的，如果没对CSS初始化往往会出现浏览器之间的页面显示差异</p>
<pre><code>最简单粗暴的

 * {
    margin: 0;
    padding: 0;
}
更好的选择Normalize.css 相比于传统的CSS reset，Normalize.css是一种现代的、为HTML5准备的优质替代方案

Reset CSS:只选对的，不选&quot;贵&quot;的，因根据具体项目来做选择权衡，不应该滥用
</code></pre></blockquote>
<ol>
<li>css定义的权重？</li>
</ol>
<blockquote>
<p>页面显示样式的优先级取决于其“特殊性”’，特殊性越高，就显示最高的，当特殊性相等时，显示后者<br>    特殊性表述为4个部分：0,0,0,0<br>    一个选择器的特殊性如下确定：</p>
<pre><code>对于选择器是#id的属性值,特殊性值为：0,1,0,0
对于属性选择器，class或伪类，特殊性值为：0,0,1,0
对于标签选择器或伪元素，特殊性值为：0,0,0,1
通配符‘*’对特殊性值为：0,0,0,0
内联样式特殊性值为：1,0,0,0
</code></pre></blockquote>
<ol>
<li>讲讲position的值relative和absolute的区别？</li>
</ol>
<blockquote>
<p>absolute：生成绝对定位的元素，相对于值不为 static的第一个父元素进行定位</p>
<pre><code>relative：生成相对定位的元素，相对于其正常位置进行定位
</code></pre><p>​</p>
</blockquote>
<ol>
<li>如何水平垂直居中div？（至少给出2种解决方法）</li>
</ol>
<p>1.absolute + transform:</p>
<pre><code>&lt;div class=&quot;parent&quot;&gt;
  &lt;div class=&quot;child&quot;&gt;Demo&lt;/div&gt;
&lt;/div&gt;

&lt;style&gt;
  .parent {
position: relative;
  }
  .child {
position: absolute;
left: 50%;
top: 50%;
transform: translate(-50%, -50%);
  }
&lt;/style&gt;
</code></pre><p>2.inline-block + text-align + table-cell + vertical-align</p>
<pre><code>&lt;div class=&quot;parent&quot;&gt;
  &lt;div class=&quot;child&quot;&gt;Demo&lt;/div&gt;
&lt;/div&gt;

&lt;style&gt;
  .parent {
text-align: center;
display: table-cell;
vertical-align: middle;
  }
  .child {
display: inline-block;
  }
&lt;/style&gt;
</code></pre><p>3.flex + justify-content + align-items</p>
<pre><code>&lt;div class=&quot;parent&quot;&gt;
  &lt;div class=&quot;child&quot;&gt;Demo&lt;/div&gt;
&lt;/div&gt;

&lt;style&gt;
  .parent {
display: flex;
justify-content: center; /* 水平居中 */
align-items: center; /*垂直居中*/
  }
&lt;/style&gt;
</code></pre><p>更多布局示例请移步CSS常见布局解决方案 垂直居中，水平居中，各种布局</p>
<ol>
<li>渐进增强 VS 优雅降级，你怎么看？</li>
</ol>
<blockquote>
<p>渐进增强（Progressive Enhancement）：一开始就针对低版本浏览器进行构建页面，完成基本的功能，然后再针对高级浏览器进行效果、交互、追加功能达到更好的体验</p>
<pre><code>优雅降级（Graceful Degradation）：一开始就构建站点的完整功能，然后针对浏览器测试和修复。比如一开始使用 CSS3 的特性构建了一个应用，然后逐步针对各大浏览器进行 hack 使其可以在低版本浏览器上正常浏览
</code></pre></blockquote>
<pre><code>二者如何抉择： 这是个人观点。。。
</code></pre><ol>
<li>JavaScript 的数据类型</li>
</ol>
<blockquote>
<p>javascript有六种基本数据类型：Undefined，Null，Boolean，Symbol(es6)，Number和String<br>    还有一种复杂数据类型：对象</p>
</blockquote>
<ol>
<li>JavaScript 数组去重？(简述思路即可)</li>
</ol>
<blockquote>
<p>遍历数组法： 这应该是最简单的去重方法（实现思路：新建一新数组，遍历数组，值不在新数组就加入该新数组中）</p>
<pre><code>// 遍历数组去重法
function unique(arr){
  var _arr = []
  //遍历当前数组
  for(var i = 0; i &lt; arr.length; i++){
    //如果当前数组的第i已经保存进了临时数组，那么跳过，
    //否则把当前项push到临时数组里面
    if (_arr.indexOf(arr[i]) == -1) _arr.push(arr[i])
  }
  return _arr
}

注意点：indexOf 为 ES5 的方法，注意浏览器兼容，需要自己实现 indexOf

对象键值对(hash) 法：速度快，高效，占用更大的内存换取更快的时间，用 JavaScript 中的 Object 对象来当做哈希表，hash去重的核心是构建了一个 hash 对象来替代 indexOf
</code></pre></blockquote>
<p> hash 去重法</p>
<blockquote>
<pre><code>function unique(arr){
   var _arr = [], 
   hash = {}

   for (var i = 0; i &lt; arr.length; i++) {
   var item = arr[i]
   var key = typeof(item) + item

   // 对象的键值只能是字符串, typeof(item) + item来去分1和&apos;1&apos;的情况

   if(hash[key] !== 1){
      _arr.push(item)
      hash[key] = 1
      }
   }
     return _arr
   }
</code></pre><p>炫酷的 es6 Set数据结构: ES6 提供了新的数据结构 Set。它类似于数组，但是成员的值都是唯一的，没有重复的值</p>
<pre><code>function unique(arr){
    return Array.from(new Set(arr))
    // Array.from方法用于将两类对象转为真正的数组：
    // 类似数组的对象（array-like object）和可遍历（iterable）的对象
}
关于 JavaScript 数组去重，还有很多很多可以讲，篇幅有限，这里介绍了几种常规的，更多的自己去探索
</code></pre></blockquote>
<ol>
<li>看如下 JavaScript 代码，给出代码运行结果？（并简述原因)</li>
</ol>
<blockquote>
<p>  var a = 2</p>
<pre><code>function foo() {
  console.log(a) // 1.???
  console.log(bar())  // 2.???
  var a = 1
  function bar(){
     return a
  }
    console.log(bar())  // 3.???  
}
foo()
console.log(a) // 4. ???

代码运行结果： 1: undefined，2: undefined，3: 1，4: 2
</code></pre></blockquote>
<pre><code>这里考察了 JavaScript 的作用域和变量提升。

在 JavaScript 中，函数、变量的声明都会被提升（hoisting）到该函数或变量所在的 scope 的顶部

JavaScript 采用词法作用域(lexical scoping)，也就是静态作用域，函数作用域在函数定义时就决定了 ，同时在es6 前 JavaScript是没有块级区域(block-level scope)，而只有函数域 (function-level scope)。（在es6前我们可过闭包来实现类似块级作用域的效果）所谓函数作用域就是：变量在声明它们的函数体以及这个函数体嵌套的任意函数体内都是有定义的
</code></pre><blockquote>
<p>  var a = 2<br>    function foo() {    // var a –变量提升<br>      console.log(a) // 1.???<br>       // 虽然在函数作用域里，这个 a 还未声明，<br>       // 实际上由于变量提升此刻的在函数头部已经定义了 a 只是尚未赋值<br>       // 所以1处的值是undefined<br>      console.log(bar())  // 2.???<br>      // 理解了第一个第二个也不难了<br>      // 结果也为 undefined<br>      var a = 1<br>      function bar(){<br>          return a<br>      }<br>      console.log(bar())  // 3.???<br>      // 此刻a已经被赋值1<br>      // 结果为 1<br>    }</p>
<pre><code>foo()
console.log(a) // 4. ???
// 函数作用域不会对全局作用域产生影响，
// 结果为2
</code></pre></blockquote>
<ol>
<li>使用原生ajax获取 Linus Torvalds 的GitHub信息(API:<a href="https://api.github.com/users/torvalds，如记不清具体代码简述过程即可)，并将JSON字符串解析为JSON对象，并讲讲对JSON的了解" target="_blank" rel="external">https://api.github.com/users/torvalds，如记不清具体代码简述过程即可)，并将JSON字符串解析为JSON对象，并讲讲对JSON的了解</a></li>
</ol>
<blockquote>
<p>这是对 ajax与json的考察</p>
<pre><code>ajax的全称：Asynchronous Javascript And XML，异步传输+js+xml 现在差不多都用JSON

创建XMLHttpRequest对象,也就是创建一个异步调用对象
创建一个新的HTTP请求,并指定该HTTP请求的方法、URL及验证信息
设置响应HTTP请求状态变化的函数
发送HTTP请求
获取异步调用返回的数据
数据处理
</code></pre></blockquote>
<p>下面就来贴代码吧：</p>
<blockquote>
<p>var api = ‘<a href="https://api.github.com/users/torvalds" target="_blank" rel="external">https://api.github.com/users/torvalds</a>‘<br>var xhr = new XMLHttpRequest() // 创建XMLHttpRequest对象</p>
<p>if(window.XMLHttpRequest){ // 兼容处理<br>    xhr = new XMLHttpRequest()<br>}else{<br>    xhr = new ActiveXObject(‘Microsoft.XMLHTTP’)// 兼容ie6以下下<br>}</p>
<p>xhr.open(‘get’,api,true)    //设置请求信息<br>xhr.send()  //提交请求</p>
<pre><code>//等待服务器返回内容
 xhr.onreadystatechange = function() {
        if ( xhr.readyState == 4 &amp;&amp; xhr.status == 200 ) {
        console.log(JSON.parse(xhr.responseText)) // 使用JSON.parse解析JSON字符串
     } 
}
</code></pre></blockquote>
<pre><code>上面这端代码应该就是最简单的一个完整的AJax，当然了，你可以对它进行各种封装，甚至结合promise，async/await。。。鸟枪换炮
</code></pre><blockquote>
<p>JSON(JavaScript Object Notation) 是一种轻量级的数据交换格式。它是基于JavaScript的一个子集。数据格式简单, 易于读写, 占用带宽小 如：{“age”:”12”, “name”:”back”}</p>
<pre><code>JSON.parse() 方法解析一个JSON字符串

JSON.stringify() 方法将一个JavaScript值转换为一个JSON字符串

eval也能解析JSON字符串，但不推荐

关于JSON就不多说了，前面写过一篇 JSON入门
</code></pre></blockquote>
<ol>
<li>简单谈谈前端性能优化</li>
</ol>
<blockquote>
<p>减少http请求次数：CSS Sprites, JS、CSS源码压缩、图片大小控制合适；网页Gzip，CDN托管，data缓存 ，图片服务器。<br>减少DOM操作次数，优化javascript性能。<br>少用全局变量、缓存DOM节点查找的结果。减少IO读取操作。<br>尽量避免使用CSS Expression（css表达式)又称Dynamic properties(动态属性)。<br>图片预加载，将样式表放在顶部，将脚本放在底部。</p>
</blockquote>

      
    </div>
    
    <div class="article-info article-info-index">
      
      

      
      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>









  
  
</div>
      <footer id="footer">
    <div class="outer">
        <div id="footer-info">
            <div class="footer-left">
                <i class="fa fa-copyright"></i> 
                2017 ying
            </div>
            <div class="footer-right">
                <a href="http://hexo.io/" target="_blank" title="快速、简洁且高效的博客框架">Hexo</a>  Theme <a href="https://github.com/MOxFIVE/hexo-theme-yelee" target="_blank" title="简而不减 Hexo 双栏博客主题  v3.5">Yelee</a> by MOxFIVE <i class="fa fa-heart animated infinite pulse"></i>
            </div>
        </div>
        
            <div class="visit">
                
                    <span id="busuanzi_container_site_pv" style='display:none'>
                        <span id="site-visit" title="本站到访数"><i class="fa fa-user" aria-hidden="true"></i><span id="busuanzi_value_site_uv"></span>
                        </span>
                    </span>
                
                
                    <span>| </span>
                
                
                    <span id="busuanzi_container_page_pv" style='display:none'>
                        <span id="page-visit"  title="本页阅读量"><i class="fa fa-eye animated infinite pulse" aria-hidden="true"></i><span id="busuanzi_value_page_pv"></span>
                        </span>
                    </span>
                
            </div>
        
    </div>
</footer>
    </div>
    
<script data-main="/js/main.js" src="//cdn.bootcss.com/require.js/2.2.0/require.min.js"></script>

    <script>
        $(document).ready(function() {
            var iPad = window.navigator.userAgent.indexOf('iPad');
            if (iPad > -1 || $(".left-col").css("display") === "none") {
                var bgColorList = ["#9db3f4", "#414141", "#e5a859", "#f5dfc6", "#c084a0", "#847e72", "#cd8390", "#996731"];
                var bgColor = Math.ceil(Math.random() * (bgColorList.length - 1));
                $("body").css({"background-color": bgColorList[bgColor], "background-size": "cover"});
            }
            else {
                var backgroundnum = 5;
                var backgroundimg = "url(/background/bg-x.jpg)".replace(/x/gi, Math.ceil(Math.random() * backgroundnum));
                $("body").css({"background": backgroundimg, "background-attachment": "fixed", "background-size": "cover"});
            }
        })
    </script>





<div class="scroll" id="scroll">
    <a href="#" title="返回顶部"><i class="fa fa-arrow-up"></i></a>
    <a href="#comments" onclick="load$hide();" title="查看评论"><i class="fa fa-comments-o"></i></a>
    <a href="#footer" title="转到底部"><i class="fa fa-arrow-down"></i></a>
</div>
<script>
    // Open in New Window
    
        var oOpenInNew = {
            
            
            
            
             categories: ".article-category a, a.tag-list-link", 
             articleNav: "#article-nav a, #post-nav-button a", 
             archives: ".archive-article-title", 
             miniArchives: "a.post-list-link", 
             menu: ".header-menu a", 
             friends: "#js-friends a", 
             socail: ".social a" 
        }
        for (var x in oOpenInNew) {
            $(oOpenInNew[x]).attr("target", "_blank");
        }
    
</script>

<script async src="https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js">
</script>
  </div>
</body>
</html>